/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scalingFactor": () => (/* binding */ scalingFactor),
/* harmony export */   "assetSize": () => (/* binding */ assetSize),
/* harmony export */   "oppositeColor": () => (/* binding */ oppositeColor),
/* harmony export */   "colorName": () => (/* binding */ colorName),
/* harmony export */   "getAsset": () => (/* binding */ getAsset),
/* harmony export */   "getColor": () => (/* binding */ getColor),
/* harmony export */   "getEmphasis": () => (/* binding */ getEmphasis),
/* harmony export */   "getX": () => (/* binding */ getX),
/* harmony export */   "getY": () => (/* binding */ getY),
/* harmony export */   "withMoved": () => (/* binding */ withMoved),
/* harmony export */   "with2Spaces": () => (/* binding */ with2Spaces),
/* harmony export */   "withPosition": () => (/* binding */ withPosition),
/* harmony export */   "isPromotionEligible": () => (/* binding */ isPromotionEligible),
/* harmony export */   "pawnOffsetHelper": () => (/* binding */ pawnOffsetHelper)
/* harmony export */ });
// Generated by ReScript, PLEASE EDIT WITH CARE


function oppositeColor(color) {
  if (color) {
    return /* White */0;
  } else {
    return /* Black */1;
  }
}

function colorName(color) {
  if (color) {
    return "Black";
  } else {
    return "White";
  }
}

function getAsset(piece) {
  switch (piece.TAG | 0) {
    case /* Pawn */0 :
        var color = piece._0.color;
        return "assets/" + (
                color ? "Black" : "White"
              ) + "/pawn";
    case /* King */1 :
        var color$1 = piece._0.color;
        return "assets/" + (
                color$1 ? "Black" : "White"
              ) + "/king";
    case /* Queen */2 :
        var color$2 = piece._0.color;
        return "assets/" + (
                color$2 ? "Black" : "White"
              ) + "/queen";
    case /* Bishop */3 :
        var color$3 = piece._0.color;
        return "assets/" + (
                color$3 ? "Black" : "White"
              ) + "/bishop";
    case /* Knight */4 :
        var color$4 = piece._0.color;
        return "assets/" + (
                color$4 ? "Black" : "White"
              ) + "/knight";
    case /* Rook */5 :
        var color$5 = piece._0.color;
        return "assets/" + (
                color$5 ? "Black" : "White"
              ) + "/rook";
    
  }
}

function getColor(piece) {
  return piece._0.color;
}

function getEmphasis(piece) {
  return piece._0.emphasizeCoverRange;
}

function getX(piece) {
  return piece._0.x;
}

function getY(piece) {
  return piece._0.y;
}

function withMoved(piece) {
  var withMovedHelper = function (p, y) {
    if (p.hasMoved) {
      return piece;
    } else {
      return y;
    }
  };
  switch (piece.TAG | 0) {
    case /* Pawn */0 :
        var p = piece._0;
        return withMovedHelper(p, {
                    TAG: /* Pawn */0,
                    _0: {
                      x: p.x,
                      y: p.y,
                      color: p.color,
                      hasMoved: true,
                      emphasizeCoverRange: p.emphasizeCoverRange,
                      hasJustMoved2Spaces: p.hasJustMoved2Spaces
                    }
                  });
    case /* King */1 :
        var k = piece._0;
        return withMovedHelper(k, {
                    TAG: /* King */1,
                    _0: {
                      x: k.x,
                      y: k.y,
                      color: k.color,
                      hasMoved: true,
                      emphasizeCoverRange: k.emphasizeCoverRange,
                      inCheck: k.inCheck,
                      checkmated: k.checkmated
                    }
                  });
    case /* Queen */2 :
        var p$1 = piece._0;
        return withMovedHelper(p$1, {
                    TAG: /* Queen */2,
                    _0: {
                      x: p$1.x,
                      y: p$1.y,
                      color: p$1.color,
                      hasMoved: true,
                      emphasizeCoverRange: p$1.emphasizeCoverRange
                    }
                  });
    case /* Bishop */3 :
        var p$2 = piece._0;
        return withMovedHelper(p$2, {
                    TAG: /* Bishop */3,
                    _0: {
                      x: p$2.x,
                      y: p$2.y,
                      color: p$2.color,
                      hasMoved: true,
                      emphasizeCoverRange: p$2.emphasizeCoverRange
                    }
                  });
    case /* Knight */4 :
        var p$3 = piece._0;
        return withMovedHelper(p$3, {
                    TAG: /* Knight */4,
                    _0: {
                      x: p$3.x,
                      y: p$3.y,
                      color: p$3.color,
                      hasMoved: true,
                      emphasizeCoverRange: p$3.emphasizeCoverRange
                    }
                  });
    case /* Rook */5 :
        var p$4 = piece._0;
        return withMovedHelper(p$4, {
                    TAG: /* Rook */5,
                    _0: {
                      x: p$4.x,
                      y: p$4.y,
                      color: p$4.color,
                      hasMoved: true,
                      emphasizeCoverRange: p$4.emphasizeCoverRange
                    }
                  });
    
  }
}

function with2Spaces(p) {
  return {
          TAG: /* Pawn */0,
          _0: {
            x: p.x,
            y: p.y,
            color: p.color,
            hasMoved: true,
            emphasizeCoverRange: p.emphasizeCoverRange,
            hasJustMoved2Spaces: true
          }
        };
}

function withPosition(piece, param) {
  var y = param[1];
  var x = param[0];
  switch (piece.TAG | 0) {
    case /* Pawn */0 :
        var p = piece._0;
        return {
                TAG: /* Pawn */0,
                _0: {
                  x: x,
                  y: y,
                  color: p.color,
                  hasMoved: p.hasMoved,
                  emphasizeCoverRange: p.emphasizeCoverRange,
                  hasJustMoved2Spaces: p.hasJustMoved2Spaces
                }
              };
    case /* King */1 :
        var k = piece._0;
        return {
                TAG: /* King */1,
                _0: {
                  x: x,
                  y: y,
                  color: k.color,
                  hasMoved: k.hasMoved,
                  emphasizeCoverRange: k.emphasizeCoverRange,
                  inCheck: k.inCheck,
                  checkmated: k.checkmated
                }
              };
    case /* Queen */2 :
        var p$1 = piece._0;
        return {
                TAG: /* Queen */2,
                _0: {
                  x: x,
                  y: y,
                  color: p$1.color,
                  hasMoved: p$1.hasMoved,
                  emphasizeCoverRange: p$1.emphasizeCoverRange
                }
              };
    case /* Bishop */3 :
        var p$2 = piece._0;
        return {
                TAG: /* Bishop */3,
                _0: {
                  x: x,
                  y: y,
                  color: p$2.color,
                  hasMoved: p$2.hasMoved,
                  emphasizeCoverRange: p$2.emphasizeCoverRange
                }
              };
    case /* Knight */4 :
        var p$3 = piece._0;
        return {
                TAG: /* Knight */4,
                _0: {
                  x: x,
                  y: y,
                  color: p$3.color,
                  hasMoved: p$3.hasMoved,
                  emphasizeCoverRange: p$3.emphasizeCoverRange
                }
              };
    case /* Rook */5 :
        var p$4 = piece._0;
        return {
                TAG: /* Rook */5,
                _0: {
                  x: x,
                  y: y,
                  color: p$4.color,
                  hasMoved: p$4.hasMoved,
                  emphasizeCoverRange: p$4.emphasizeCoverRange
                }
              };
    
  }
}

function isPromotionEligible(piece) {
  if (piece.color === /* White */0 && piece.y === 7) {
    return true;
  } else if (piece.color === /* Black */1) {
    return piece.y === 0;
  } else {
    return false;
  }
}

function pawnOffsetHelper(p, n) {
  var match = p.color;
  if (match) {
    return -n | 0;
  } else {
    return n;
  }
}

var scalingFactor = 4;

var assetSize = 23;


/* No side effect */


/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Generated by ReScript, PLEASE EDIT WITH CARE


var Curry = __webpack_require__(3);
var Utils = __webpack_require__(1);
var Belt_List = __webpack_require__(5);

function getPiece(board, param, color) {
  var y = param[1];
  var x = param[0];
  return Belt_List.getBy(board.pieces, (function (p) {
                var colorPredicate = color !== undefined ? Utils.getColor(p) === color : true;
                if (Utils.getX(p) === x && Utils.getY(p) === y) {
                  return colorPredicate;
                } else {
                  return false;
                }
              }));
}

function hasPiece(board, position, color) {
  return getPiece(board, position, color) !== undefined;
}

function hasOppositeColoredPiece(board, position, color) {
  return hasPiece(board, position, Utils.oppositeColor(color));
}

function checkUnobstructed(board, piece, param, canCapture) {
  var y = param[1];
  var x = param[0];
  if (x < 0 || x > 7 || y < 0 || y > 7) {
    return false;
  }
  if (!canCapture) {
    return !hasPiece(board, [
                x,
                y
              ], undefined);
  }
  var target = getPiece(board, [
        x,
        y
      ], undefined);
  if (target !== undefined) {
    if (target.TAG === /* King */1) {
      return false;
    } else {
      return Utils.getColor(target) !== piece.color;
    }
  } else {
    return true;
  }
}

function confirmMove(board, piece, position) {
  var newY = position[1];
  var newX = position[0];
  var match;
  switch (piece.TAG | 0) {
    case /* Pawn */0 :
        var p = piece._0;
        var newPawn = (p.y - newY | 0) === -2 || (p.y - newY | 0) === 2 ? Utils.withPosition(Utils.with2Spaces(p), position) : Utils.withMoved(Utils.withPosition(piece, position));
        var callback = p.x !== newX && p.y !== newY && hasPiece(board, position, undefined) ? (function (b) {
              return {
                      pieces: Belt_List.keep(b.pieces, (function (i) {
                              if (Utils.getX(i) !== newX) {
                                return true;
                              } else {
                                return Utils.getY(i) !== p.y;
                              }
                            }))
                    };
            }) : undefined;
        match = [
          newPawn,
          callback
        ];
        break;
    case /* King */1 :
        var k = piece._0;
        var match$1 = k.color;
        var backRowY = match$1 ? 7 : 0;
        var castleHelper = function (oldRookX, newRookX, board) {
          var rook = getPiece(board, [
                oldRookX,
                backRowY
              ], undefined);
          if (rook !== undefined) {
            return function (b) {
              return confirmMove(b, rook, [
                          newRookX,
                          backRowY
                        ]);
            };
          }
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        };
        match = k.hasMoved ? [
            Utils.withMoved(Utils.withPosition(piece, position)),
            undefined
          ] : (
            newX === 2 && newY === backRowY ? [
                Utils.withMoved(Utils.withPosition(piece, position)),
                castleHelper(0, 3, board)
              ] : (
                newX === 6 && newY === backRowY ? [
                    Utils.withMoved(Utils.withPosition(piece, position)),
                    castleHelper(7, 5, board)
                  ] : [
                    Utils.withMoved(Utils.withPosition(piece, position)),
                    undefined
                  ]
              )
          );
        break;
    default:
      match = [
        Utils.withMoved(Utils.withPosition(piece, position)),
        undefined
      ];
  }
  var callback$1 = match[1];
  var pieces_0 = match[0];
  var pieces_1 = Belt_List.keep(board.pieces, (function (p) {
          if (Utils.getX(p) !== Utils.getX(piece) || Utils.getY(p) !== Utils.getY(piece) || Utils.getX(p) !== newX) {
            return true;
          } else {
            return Utils.getY(p) !== newY;
          }
        }));
  var pieces = {
    hd: pieces_0,
    tl: pieces_1
  };
  var newBoard = {
    pieces: pieces
  };
  if (callback$1 !== undefined) {
    return Curry._1(callback$1, newBoard);
  } else {
    return newBoard;
  }
}

exports.getPiece = getPiece;
exports.hasPiece = hasPiece;
exports.hasOppositeColoredPiece = hasOppositeColoredPiece;
exports.checkUnobstructed = checkUnobstructed;
exports.confirmMove = confirmMove;
/* No side effect */


/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



var Caml_array = __webpack_require__(4);

function app(_f, _args) {
  while(true) {
    var args = _args;
    var f = _f;
    var init_arity = f.length;
    var arity = init_arity === 0 ? 1 : init_arity;
    var len = args.length;
    var d = arity - len | 0;
    if (d === 0) {
      return f.apply(null, args);
    }
    if (d >= 0) {
      return (function(f,args){
      return function (x) {
        return app(f, args.concat([x]));
      }
      }(f,args));
    }
    _args = Caml_array.sub(args, arity, -d | 0);
    _f = f.apply(null, Caml_array.sub(args, 0, arity));
    continue ;
  };
}

function _1(o, a0) {
  var arity = o.length;
  if (arity === 1) {
    return o(a0);
  } else {
    switch (arity) {
      case 1 :
          return o(a0);
      case 2 :
          return function (param) {
            return o(a0, param);
          };
      case 3 :
          return function (param, param$1) {
            return o(a0, param, param$1);
          };
      case 4 :
          return function (param, param$1, param$2) {
            return o(a0, param, param$1, param$2);
          };
      case 5 :
          return function (param, param$1, param$2, param$3) {
            return o(a0, param, param$1, param$2, param$3);
          };
      case 6 :
          return function (param, param$1, param$2, param$3, param$4) {
            return o(a0, param, param$1, param$2, param$3, param$4);
          };
      case 7 :
          return function (param, param$1, param$2, param$3, param$4, param$5) {
            return o(a0, param, param$1, param$2, param$3, param$4, param$5);
          };
      default:
        return app(o, [a0]);
    }
  }
}

function __1(o) {
  var arity = o.length;
  if (arity === 1) {
    return o;
  } else {
    return function (a0) {
      return _1(o, a0);
    };
  }
}

function _2(o, a0, a1) {
  var arity = o.length;
  if (arity === 2) {
    return o(a0, a1);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [a1]);
      case 2 :
          return o(a0, a1);
      case 3 :
          return function (param) {
            return o(a0, a1, param);
          };
      case 4 :
          return function (param, param$1) {
            return o(a0, a1, param, param$1);
          };
      case 5 :
          return function (param, param$1, param$2) {
            return o(a0, a1, param, param$1, param$2);
          };
      case 6 :
          return function (param, param$1, param$2, param$3) {
            return o(a0, a1, param, param$1, param$2, param$3);
          };
      case 7 :
          return function (param, param$1, param$2, param$3, param$4) {
            return o(a0, a1, param, param$1, param$2, param$3, param$4);
          };
      default:
        return app(o, [
                    a0,
                    a1
                  ]);
    }
  }
}

function __2(o) {
  var arity = o.length;
  if (arity === 2) {
    return o;
  } else {
    return function (a0, a1) {
      return _2(o, a0, a1);
    };
  }
}

function _3(o, a0, a1, a2) {
  var arity = o.length;
  if (arity === 3) {
    return o(a0, a1, a2);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2
                    ]);
      case 2 :
          return app(o(a0, a1), [a2]);
      case 3 :
          return o(a0, a1, a2);
      case 4 :
          return function (param) {
            return o(a0, a1, a2, param);
          };
      case 5 :
          return function (param, param$1) {
            return o(a0, a1, a2, param, param$1);
          };
      case 6 :
          return function (param, param$1, param$2) {
            return o(a0, a1, a2, param, param$1, param$2);
          };
      case 7 :
          return function (param, param$1, param$2, param$3) {
            return o(a0, a1, a2, param, param$1, param$2, param$3);
          };
      default:
        return app(o, [
                    a0,
                    a1,
                    a2
                  ]);
    }
  }
}

function __3(o) {
  var arity = o.length;
  if (arity === 3) {
    return o;
  } else {
    return function (a0, a1, a2) {
      return _3(o, a0, a1, a2);
    };
  }
}

function _4(o, a0, a1, a2, a3) {
  var arity = o.length;
  if (arity === 4) {
    return o(a0, a1, a2, a3);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [a3]);
      case 4 :
          return o(a0, a1, a2, a3);
      case 5 :
          return function (param) {
            return o(a0, a1, a2, a3, param);
          };
      case 6 :
          return function (param, param$1) {
            return o(a0, a1, a2, a3, param, param$1);
          };
      case 7 :
          return function (param, param$1, param$2) {
            return o(a0, a1, a2, a3, param, param$1, param$2);
          };
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3
                  ]);
    }
  }
}

function __4(o) {
  var arity = o.length;
  if (arity === 4) {
    return o;
  } else {
    return function (a0, a1, a2, a3) {
      return _4(o, a0, a1, a2, a3);
    };
  }
}

function _5(o, a0, a1, a2, a3, a4) {
  var arity = o.length;
  if (arity === 5) {
    return o(a0, a1, a2, a3, a4);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3,
                      a4
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3,
                      a4
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [
                      a3,
                      a4
                    ]);
      case 4 :
          return app(o(a0, a1, a2, a3), [a4]);
      case 5 :
          return o(a0, a1, a2, a3, a4);
      case 6 :
          return function (param) {
            return o(a0, a1, a2, a3, a4, param);
          };
      case 7 :
          return function (param, param$1) {
            return o(a0, a1, a2, a3, a4, param, param$1);
          };
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3,
                    a4
                  ]);
    }
  }
}

function __5(o) {
  var arity = o.length;
  if (arity === 5) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4) {
      return _5(o, a0, a1, a2, a3, a4);
    };
  }
}

function _6(o, a0, a1, a2, a3, a4, a5) {
  var arity = o.length;
  if (arity === 6) {
    return o(a0, a1, a2, a3, a4, a5);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3,
                      a4,
                      a5
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3,
                      a4,
                      a5
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [
                      a3,
                      a4,
                      a5
                    ]);
      case 4 :
          return app(o(a0, a1, a2, a3), [
                      a4,
                      a5
                    ]);
      case 5 :
          return app(o(a0, a1, a2, a3, a4), [a5]);
      case 6 :
          return o(a0, a1, a2, a3, a4, a5);
      case 7 :
          return function (param) {
            return o(a0, a1, a2, a3, a4, a5, param);
          };
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3,
                    a4,
                    a5
                  ]);
    }
  }
}

function __6(o) {
  var arity = o.length;
  if (arity === 6) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4, a5) {
      return _6(o, a0, a1, a2, a3, a4, a5);
    };
  }
}

function _7(o, a0, a1, a2, a3, a4, a5, a6) {
  var arity = o.length;
  if (arity === 7) {
    return o(a0, a1, a2, a3, a4, a5, a6);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3,
                      a4,
                      a5,
                      a6
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3,
                      a4,
                      a5,
                      a6
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [
                      a3,
                      a4,
                      a5,
                      a6
                    ]);
      case 4 :
          return app(o(a0, a1, a2, a3), [
                      a4,
                      a5,
                      a6
                    ]);
      case 5 :
          return app(o(a0, a1, a2, a3, a4), [
                      a5,
                      a6
                    ]);
      case 6 :
          return app(o(a0, a1, a2, a3, a4, a5), [a6]);
      case 7 :
          return o(a0, a1, a2, a3, a4, a5, a6);
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6
                  ]);
    }
  }
}

function __7(o) {
  var arity = o.length;
  if (arity === 7) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4, a5, a6) {
      return _7(o, a0, a1, a2, a3, a4, a5, a6);
    };
  }
}

function _8(o, a0, a1, a2, a3, a4, a5, a6, a7) {
  var arity = o.length;
  if (arity === 8) {
    return o(a0, a1, a2, a3, a4, a5, a6, a7);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [
                      a3,
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 4 :
          return app(o(a0, a1, a2, a3), [
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 5 :
          return app(o(a0, a1, a2, a3, a4), [
                      a5,
                      a6,
                      a7
                    ]);
      case 6 :
          return app(o(a0, a1, a2, a3, a4, a5), [
                      a6,
                      a7
                    ]);
      case 7 :
          return app(o(a0, a1, a2, a3, a4, a5, a6), [a7]);
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6,
                    a7
                  ]);
    }
  }
}

function __8(o) {
  var arity = o.length;
  if (arity === 8) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4, a5, a6, a7) {
      return _8(o, a0, a1, a2, a3, a4, a5, a6, a7);
    };
  }
}

exports.app = app;
exports._1 = _1;
exports.__1 = __1;
exports._2 = _2;
exports.__2 = __2;
exports._3 = _3;
exports.__3 = __3;
exports._4 = _4;
exports.__4 = __4;
exports._5 = _5;
exports.__5 = __5;
exports._6 = _6;
exports.__6 = __6;
exports._7 = _7;
exports.__7 = __7;
exports._8 = _8;
exports.__8 = __8;
/* No side effect */


/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, exports) => {




function sub(x, offset, len) {
  var result = new Array(len);
  var j = 0;
  var i = offset;
  while(j < len) {
    result[j] = x[i];
    j = j + 1 | 0;
    i = i + 1 | 0;
  };
  return result;
}

function len(_acc, _l) {
  while(true) {
    var l = _l;
    var acc = _acc;
    if (!l) {
      return acc;
    }
    _l = l.tl;
    _acc = l.hd.length + acc | 0;
    continue ;
  };
}

function fill(arr, _i, _l) {
  while(true) {
    var l = _l;
    var i = _i;
    if (!l) {
      return ;
    }
    var x = l.hd;
    var l$1 = x.length;
    var k = i;
    var j = 0;
    while(j < l$1) {
      arr[k] = x[j];
      k = k + 1 | 0;
      j = j + 1 | 0;
    };
    _l = l.tl;
    _i = k;
    continue ;
  };
}

function concat(l) {
  var v = len(0, l);
  var result = new Array(v);
  fill(result, 0, l);
  return result;
}

function set(xs, index, newval) {
  if (index < 0 || index >= xs.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  xs[index] = newval;
  
}

function get(xs, index) {
  if (index < 0 || index >= xs.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  return xs[index];
}

function make(len, init) {
  var b = new Array(len);
  for(var i = 0; i < len; ++i){
    b[i] = init;
  }
  return b;
}

function make_float(len) {
  var b = new Array(len);
  for(var i = 0; i < len; ++i){
    b[i] = 0;
  }
  return b;
}

function blit(a1, i1, a2, i2, len) {
  if (i2 <= i1) {
    for(var j = 0; j < len; ++j){
      a2[j + i2 | 0] = a1[j + i1 | 0];
    }
    return ;
  }
  for(var j$1 = len - 1 | 0; j$1 >= 0; --j$1){
    a2[j$1 + i2 | 0] = a1[j$1 + i1 | 0];
  }
  
}

function dup(prim) {
  return prim.slice(0);
}

exports.dup = dup;
exports.sub = sub;
exports.concat = concat;
exports.make = make;
exports.make_float = make_float;
exports.blit = blit;
exports.get = get;
exports.set = set;
/* No side effect */


/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



var Curry = __webpack_require__(3);
var Belt_Array = __webpack_require__(6);
var Caml_option = __webpack_require__(10);
var Belt_SortArray = __webpack_require__(11);

function head(x) {
  if (x) {
    return Caml_option.some(x.hd);
  }
  
}

function headExn(x) {
  if (x) {
    return x.hd;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function tail(x) {
  if (x) {
    return x.tl;
  }
  
}

function tailExn(x) {
  if (x) {
    return x.tl;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function add(xs, x) {
  return {
          hd: x,
          tl: xs
        };
}

function get(x, n) {
  if (n < 0) {
    return ;
  } else {
    var _x = x;
    var _n = n;
    while(true) {
      var n$1 = _n;
      var x$1 = _x;
      if (!x$1) {
        return ;
      }
      if (n$1 === 0) {
        return Caml_option.some(x$1.hd);
      }
      _n = n$1 - 1 | 0;
      _x = x$1.tl;
      continue ;
    };
  }
}

function getExn(x, n) {
  if (n < 0) {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  var _x = x;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var x$1 = _x;
    if (x$1) {
      if (n$1 === 0) {
        return x$1.hd;
      }
      _n = n$1 - 1 | 0;
      _x = x$1.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function partitionAux(p, _cell, _precX, _precY) {
  while(true) {
    var precY = _precY;
    var precX = _precX;
    var cell = _cell;
    if (!cell) {
      return ;
    }
    var t = cell.tl;
    var h = cell.hd;
    var next = {
      hd: h,
      tl: /* [] */0
    };
    if (p(h)) {
      precX.tl = next;
      _precX = next;
      _cell = t;
      continue ;
    }
    precY.tl = next;
    _precY = next;
    _cell = t;
    continue ;
  };
}

function splitAux(_cell, _precX, _precY) {
  while(true) {
    var precY = _precY;
    var precX = _precX;
    var cell = _cell;
    if (!cell) {
      return ;
    }
    var match = cell.hd;
    var nextA = {
      hd: match[0],
      tl: /* [] */0
    };
    var nextB = {
      hd: match[1],
      tl: /* [] */0
    };
    precX.tl = nextA;
    precY.tl = nextB;
    _precY = nextB;
    _precX = nextA;
    _cell = cell.tl;
    continue ;
  };
}

function copyAuxCont(_cellX, _prec) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return prec;
    }
    var next = {
      hd: cellX.hd,
      tl: /* [] */0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    continue ;
  };
}

function copyAuxWitFilter(f, _cellX, _prec) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return ;
    }
    var t = cellX.tl;
    var h = cellX.hd;
    if (f(h)) {
      var next = {
        hd: h,
        tl: /* [] */0
      };
      prec.tl = next;
      _prec = next;
      _cellX = t;
      continue ;
    }
    _cellX = t;
    continue ;
  };
}

function copyAuxWithFilterIndex(f, _cellX, _prec, _i) {
  while(true) {
    var i = _i;
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return ;
    }
    var t = cellX.tl;
    var h = cellX.hd;
    if (f(h, i)) {
      var next = {
        hd: h,
        tl: /* [] */0
      };
      prec.tl = next;
      _i = i + 1 | 0;
      _prec = next;
      _cellX = t;
      continue ;
    }
    _i = i + 1 | 0;
    _cellX = t;
    continue ;
  };
}

function copyAuxWitFilterMap(f, _cellX, _prec) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return ;
    }
    var t = cellX.tl;
    var h = f(cellX.hd);
    if (h !== undefined) {
      var next = {
        hd: Caml_option.valFromOption(h),
        tl: /* [] */0
      };
      prec.tl = next;
      _prec = next;
      _cellX = t;
      continue ;
    }
    _cellX = t;
    continue ;
  };
}

function removeAssocAuxWithMap(_cellX, x, _prec, f) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return false;
    }
    var t = cellX.tl;
    var h = cellX.hd;
    if (f(h[0], x)) {
      prec.tl = t;
      return true;
    }
    var next = {
      hd: h,
      tl: /* [] */0
    };
    prec.tl = next;
    _prec = next;
    _cellX = t;
    continue ;
  };
}

function setAssocAuxWithMap(_cellX, x, k, _prec, eq) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return false;
    }
    var t = cellX.tl;
    var h = cellX.hd;
    if (eq(h[0], x)) {
      prec.tl = {
        hd: [
          x,
          k
        ],
        tl: t
      };
      return true;
    }
    var next = {
      hd: h,
      tl: /* [] */0
    };
    prec.tl = next;
    _prec = next;
    _cellX = t;
    continue ;
  };
}

function copyAuxWithMap(_cellX, _prec, f) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return ;
    }
    var next = {
      hd: f(cellX.hd),
      tl: /* [] */0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    continue ;
  };
}

function zipAux(_cellX, _cellY, _prec) {
  while(true) {
    var prec = _prec;
    var cellY = _cellY;
    var cellX = _cellX;
    if (!cellX) {
      return ;
    }
    if (!cellY) {
      return ;
    }
    var next = {
      hd: [
        cellX.hd,
        cellY.hd
      ],
      tl: /* [] */0
    };
    prec.tl = next;
    _prec = next;
    _cellY = cellY.tl;
    _cellX = cellX.tl;
    continue ;
  };
}

function copyAuxWithMap2(f, _cellX, _cellY, _prec) {
  while(true) {
    var prec = _prec;
    var cellY = _cellY;
    var cellX = _cellX;
    if (!cellX) {
      return ;
    }
    if (!cellY) {
      return ;
    }
    var next = {
      hd: f(cellX.hd, cellY.hd),
      tl: /* [] */0
    };
    prec.tl = next;
    _prec = next;
    _cellY = cellY.tl;
    _cellX = cellX.tl;
    continue ;
  };
}

function copyAuxWithMapI(f, _i, _cellX, _prec) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    var i = _i;
    if (!cellX) {
      return ;
    }
    var next = {
      hd: f(i, cellX.hd),
      tl: /* [] */0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    _i = i + 1 | 0;
    continue ;
  };
}

function takeAux(_n, _cell, _prec) {
  while(true) {
    var prec = _prec;
    var cell = _cell;
    var n = _n;
    if (n === 0) {
      return true;
    }
    if (!cell) {
      return false;
    }
    var cell$1 = {
      hd: cell.hd,
      tl: /* [] */0
    };
    prec.tl = cell$1;
    _prec = cell$1;
    _cell = cell.tl;
    _n = n - 1 | 0;
    continue ;
  };
}

function splitAtAux(_n, _cell, _prec) {
  while(true) {
    var prec = _prec;
    var cell = _cell;
    var n = _n;
    if (n === 0) {
      return cell;
    }
    if (!cell) {
      return ;
    }
    var cell$1 = {
      hd: cell.hd,
      tl: /* [] */0
    };
    prec.tl = cell$1;
    _prec = cell$1;
    _cell = cell.tl;
    _n = n - 1 | 0;
    continue ;
  };
}

function take(lst, n) {
  if (n < 0) {
    return ;
  }
  if (n === 0) {
    return /* [] */0;
  }
  if (!lst) {
    return ;
  }
  var cell = {
    hd: lst.hd,
    tl: /* [] */0
  };
  var has = takeAux(n - 1 | 0, lst.tl, cell);
  if (has) {
    return cell;
  }
  
}

function drop(lst, n) {
  if (n < 0) {
    return ;
  } else {
    var _l = lst;
    var _n = n;
    while(true) {
      var n$1 = _n;
      var l = _l;
      if (n$1 === 0) {
        return l;
      }
      if (!l) {
        return ;
      }
      _n = n$1 - 1 | 0;
      _l = l.tl;
      continue ;
    };
  }
}

function splitAt(lst, n) {
  if (n < 0) {
    return ;
  }
  if (n === 0) {
    return [
            /* [] */0,
            lst
          ];
  }
  if (!lst) {
    return ;
  }
  var cell = {
    hd: lst.hd,
    tl: /* [] */0
  };
  var rest = splitAtAux(n - 1 | 0, lst.tl, cell);
  if (rest !== undefined) {
    return [
            cell,
            rest
          ];
  }
  
}

function concat(xs, ys) {
  if (!xs) {
    return ys;
  }
  var cell = {
    hd: xs.hd,
    tl: /* [] */0
  };
  copyAuxCont(xs.tl, cell).tl = ys;
  return cell;
}

function mapU(xs, f) {
  if (!xs) {
    return /* [] */0;
  }
  var cell = {
    hd: f(xs.hd),
    tl: /* [] */0
  };
  copyAuxWithMap(xs.tl, cell, f);
  return cell;
}

function map(xs, f) {
  return mapU(xs, Curry.__1(f));
}

function zipByU(l1, l2, f) {
  if (!l1) {
    return /* [] */0;
  }
  if (!l2) {
    return /* [] */0;
  }
  var cell = {
    hd: f(l1.hd, l2.hd),
    tl: /* [] */0
  };
  copyAuxWithMap2(f, l1.tl, l2.tl, cell);
  return cell;
}

function zipBy(l1, l2, f) {
  return zipByU(l1, l2, Curry.__2(f));
}

function mapWithIndexU(xs, f) {
  if (!xs) {
    return /* [] */0;
  }
  var cell = {
    hd: f(0, xs.hd),
    tl: /* [] */0
  };
  copyAuxWithMapI(f, 1, xs.tl, cell);
  return cell;
}

function mapWithIndex(xs, f) {
  return mapWithIndexU(xs, Curry.__2(f));
}

function makeByU(n, f) {
  if (n <= 0) {
    return /* [] */0;
  }
  var headX = {
    hd: f(0),
    tl: /* [] */0
  };
  var cur = headX;
  var i = 1;
  while(i < n) {
    var v = {
      hd: f(i),
      tl: /* [] */0
    };
    cur.tl = v;
    cur = v;
    i = i + 1 | 0;
  };
  return headX;
}

function makeBy(n, f) {
  return makeByU(n, Curry.__1(f));
}

function make(n, v) {
  if (n <= 0) {
    return /* [] */0;
  }
  var headX = {
    hd: v,
    tl: /* [] */0
  };
  var cur = headX;
  var i = 1;
  while(i < n) {
    var v$1 = {
      hd: v,
      tl: /* [] */0
    };
    cur.tl = v$1;
    cur = v$1;
    i = i + 1 | 0;
  };
  return headX;
}

function length(xs) {
  var _x = xs;
  var _acc = 0;
  while(true) {
    var acc = _acc;
    var x = _x;
    if (!x) {
      return acc;
    }
    _acc = acc + 1 | 0;
    _x = x.tl;
    continue ;
  };
}

function fillAux(arr, _i, _x) {
  while(true) {
    var x = _x;
    var i = _i;
    if (!x) {
      return ;
    }
    arr[i] = x.hd;
    _x = x.tl;
    _i = i + 1 | 0;
    continue ;
  };
}

function fromArray(a) {
  var _i = a.length - 1 | 0;
  var _res = /* [] */0;
  while(true) {
    var res = _res;
    var i = _i;
    if (i < 0) {
      return res;
    }
    _res = {
      hd: a[i],
      tl: res
    };
    _i = i - 1 | 0;
    continue ;
  };
}

function toArray(x) {
  var len = length(x);
  var arr = new Array(len);
  fillAux(arr, 0, x);
  return arr;
}

function shuffle(xs) {
  var v = toArray(xs);
  Belt_Array.shuffleInPlace(v);
  return fromArray(v);
}

function reverseConcat(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      return l2;
    }
    _l2 = {
      hd: l1.hd,
      tl: l2
    };
    _l1 = l1.tl;
    continue ;
  };
}

function reverse(l) {
  return reverseConcat(l, /* [] */0);
}

function flattenAux(_prec, _xs) {
  while(true) {
    var xs = _xs;
    var prec = _prec;
    if (xs) {
      _xs = xs.tl;
      _prec = copyAuxCont(xs.hd, prec);
      continue ;
    }
    prec.tl = /* [] */0;
    return ;
  };
}

function flatten(_xs) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return /* [] */0;
    }
    var match = xs.hd;
    if (match) {
      var cell = {
        hd: match.hd,
        tl: /* [] */0
      };
      flattenAux(copyAuxCont(match.tl, cell), xs.tl);
      return cell;
    }
    _xs = xs.tl;
    continue ;
  };
}

function concatMany(xs) {
  var len = xs.length;
  if (len === 1) {
    return xs[0];
  }
  if (len === 0) {
    return /* [] */0;
  }
  var len$1 = xs.length;
  var v = xs[len$1 - 1 | 0];
  for(var i = len$1 - 2 | 0; i >= 0; --i){
    v = concat(xs[i], v);
  }
  return v;
}

function mapReverseU(l, f) {
  var _accu = /* [] */0;
  var _xs = l;
  while(true) {
    var xs = _xs;
    var accu = _accu;
    if (!xs) {
      return accu;
    }
    _xs = xs.tl;
    _accu = {
      hd: f(xs.hd),
      tl: accu
    };
    continue ;
  };
}

function mapReverse(l, f) {
  return mapReverseU(l, Curry.__1(f));
}

function forEachU(_xs, f) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return ;
    }
    f(xs.hd);
    _xs = xs.tl;
    continue ;
  };
}

function forEach(xs, f) {
  return forEachU(xs, Curry.__1(f));
}

function forEachWithIndexU(l, f) {
  var _xs = l;
  var _i = 0;
  while(true) {
    var i = _i;
    var xs = _xs;
    if (!xs) {
      return ;
    }
    f(i, xs.hd);
    _i = i + 1 | 0;
    _xs = xs.tl;
    continue ;
  };
}

function forEachWithIndex(l, f) {
  return forEachWithIndexU(l, Curry.__2(f));
}

function reduceU(_l, _accu, f) {
  while(true) {
    var accu = _accu;
    var l = _l;
    if (!l) {
      return accu;
    }
    _accu = f(accu, l.hd);
    _l = l.tl;
    continue ;
  };
}

function reduce(l, accu, f) {
  return reduceU(l, accu, Curry.__2(f));
}

function reduceReverseUnsafeU(l, accu, f) {
  if (l) {
    return f(reduceReverseUnsafeU(l.tl, accu, f), l.hd);
  } else {
    return accu;
  }
}

function reduceReverseU(l, acc, f) {
  var len = length(l);
  if (len < 1000) {
    return reduceReverseUnsafeU(l, acc, f);
  } else {
    return Belt_Array.reduceReverseU(toArray(l), acc, f);
  }
}

function reduceReverse(l, accu, f) {
  return reduceReverseU(l, accu, Curry.__2(f));
}

function reduceWithIndexU(l, acc, f) {
  var _l = l;
  var _acc = acc;
  var _i = 0;
  while(true) {
    var i = _i;
    var acc$1 = _acc;
    var l$1 = _l;
    if (!l$1) {
      return acc$1;
    }
    _i = i + 1 | 0;
    _acc = f(acc$1, l$1.hd, i);
    _l = l$1.tl;
    continue ;
  };
}

function reduceWithIndex(l, acc, f) {
  return reduceWithIndexU(l, acc, Curry.__3(f));
}

function mapReverse2U(l1, l2, f) {
  var _l1 = l1;
  var _l2 = l2;
  var _accu = /* [] */0;
  while(true) {
    var accu = _accu;
    var l2$1 = _l2;
    var l1$1 = _l1;
    if (!l1$1) {
      return accu;
    }
    if (!l2$1) {
      return accu;
    }
    _accu = {
      hd: f(l1$1.hd, l2$1.hd),
      tl: accu
    };
    _l2 = l2$1.tl;
    _l1 = l1$1.tl;
    continue ;
  };
}

function mapReverse2(l1, l2, f) {
  return mapReverse2U(l1, l2, Curry.__2(f));
}

function forEach2U(_l1, _l2, f) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      return ;
    }
    if (!l2) {
      return ;
    }
    f(l1.hd, l2.hd);
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function forEach2(l1, l2, f) {
  return forEach2U(l1, l2, Curry.__2(f));
}

function reduce2U(_l1, _l2, _accu, f) {
  while(true) {
    var accu = _accu;
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      return accu;
    }
    if (!l2) {
      return accu;
    }
    _accu = f(accu, l1.hd, l2.hd);
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function reduce2(l1, l2, acc, f) {
  return reduce2U(l1, l2, acc, Curry.__3(f));
}

function reduceReverse2UnsafeU(l1, l2, accu, f) {
  if (l1 && l2) {
    return f(reduceReverse2UnsafeU(l1.tl, l2.tl, accu, f), l1.hd, l2.hd);
  } else {
    return accu;
  }
}

function reduceReverse2U(l1, l2, acc, f) {
  var len = length(l1);
  if (len < 1000) {
    return reduceReverse2UnsafeU(l1, l2, acc, f);
  } else {
    return Belt_Array.reduceReverse2U(toArray(l1), toArray(l2), acc, f);
  }
}

function reduceReverse2(l1, l2, acc, f) {
  return reduceReverse2U(l1, l2, acc, Curry.__3(f));
}

function everyU(_xs, p) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return true;
    }
    if (!p(xs.hd)) {
      return false;
    }
    _xs = xs.tl;
    continue ;
  };
}

function every(xs, p) {
  return everyU(xs, Curry.__1(p));
}

function someU(_xs, p) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return false;
    }
    if (p(xs.hd)) {
      return true;
    }
    _xs = xs.tl;
    continue ;
  };
}

function some(xs, p) {
  return someU(xs, Curry.__1(p));
}

function every2U(_l1, _l2, p) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      return true;
    }
    if (!l2) {
      return true;
    }
    if (!p(l1.hd, l2.hd)) {
      return false;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function every2(l1, l2, p) {
  return every2U(l1, l2, Curry.__2(p));
}

function cmpByLength(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      if (l2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!l2) {
      return 1;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function cmpU(_l1, _l2, p) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      if (l2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!l2) {
      return 1;
    }
    var c = p(l1.hd, l2.hd);
    if (c !== 0) {
      return c;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function cmp(l1, l2, f) {
  return cmpU(l1, l2, Curry.__2(f));
}

function eqU(_l1, _l2, p) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      if (l2) {
        return false;
      } else {
        return true;
      }
    }
    if (!l2) {
      return false;
    }
    if (!p(l1.hd, l2.hd)) {
      return false;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function eq(l1, l2, f) {
  return eqU(l1, l2, Curry.__2(f));
}

function some2U(_l1, _l2, p) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      return false;
    }
    if (!l2) {
      return false;
    }
    if (p(l1.hd, l2.hd)) {
      return true;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function some2(l1, l2, p) {
  return some2U(l1, l2, Curry.__2(p));
}

function hasU(_xs, x, eq) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return false;
    }
    if (eq(xs.hd, x)) {
      return true;
    }
    _xs = xs.tl;
    continue ;
  };
}

function has(xs, x, eq) {
  return hasU(xs, x, Curry.__2(eq));
}

function getAssocU(_xs, x, eq) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return ;
    }
    var match = xs.hd;
    if (eq(match[0], x)) {
      return Caml_option.some(match[1]);
    }
    _xs = xs.tl;
    continue ;
  };
}

function getAssoc(xs, x, eq) {
  return getAssocU(xs, x, Curry.__2(eq));
}

function hasAssocU(_xs, x, eq) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return false;
    }
    if (eq(xs.hd[0], x)) {
      return true;
    }
    _xs = xs.tl;
    continue ;
  };
}

function hasAssoc(xs, x, eq) {
  return hasAssocU(xs, x, Curry.__2(eq));
}

function removeAssocU(xs, x, eq) {
  if (!xs) {
    return /* [] */0;
  }
  var l = xs.tl;
  var pair = xs.hd;
  if (eq(pair[0], x)) {
    return l;
  }
  var cell = {
    hd: pair,
    tl: /* [] */0
  };
  var removed = removeAssocAuxWithMap(l, x, cell, eq);
  if (removed) {
    return cell;
  } else {
    return xs;
  }
}

function removeAssoc(xs, x, eq) {
  return removeAssocU(xs, x, Curry.__2(eq));
}

function setAssocU(xs, x, k, eq) {
  if (!xs) {
    return {
            hd: [
              x,
              k
            ],
            tl: /* [] */0
          };
  }
  var l = xs.tl;
  var pair = xs.hd;
  if (eq(pair[0], x)) {
    return {
            hd: [
              x,
              k
            ],
            tl: l
          };
  }
  var cell = {
    hd: pair,
    tl: /* [] */0
  };
  var replaced = setAssocAuxWithMap(l, x, k, cell, eq);
  if (replaced) {
    return cell;
  } else {
    return {
            hd: [
              x,
              k
            ],
            tl: xs
          };
  }
}

function setAssoc(xs, x, k, eq) {
  return setAssocU(xs, x, k, Curry.__2(eq));
}

function sortU(xs, cmp) {
  var arr = toArray(xs);
  Belt_SortArray.stableSortInPlaceByU(arr, cmp);
  return fromArray(arr);
}

function sort(xs, cmp) {
  return sortU(xs, Curry.__2(cmp));
}

function getByU(_xs, p) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return ;
    }
    var x = xs.hd;
    if (p(x)) {
      return Caml_option.some(x);
    }
    _xs = xs.tl;
    continue ;
  };
}

function getBy(xs, p) {
  return getByU(xs, Curry.__1(p));
}

function keepU(_xs, p) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return /* [] */0;
    }
    var t = xs.tl;
    var h = xs.hd;
    if (p(h)) {
      var cell = {
        hd: h,
        tl: /* [] */0
      };
      copyAuxWitFilter(p, t, cell);
      return cell;
    }
    _xs = t;
    continue ;
  };
}

function keep(xs, p) {
  return keepU(xs, Curry.__1(p));
}

function keepWithIndexU(xs, p) {
  var _xs = xs;
  var _i = 0;
  while(true) {
    var i = _i;
    var xs$1 = _xs;
    if (!xs$1) {
      return /* [] */0;
    }
    var t = xs$1.tl;
    var h = xs$1.hd;
    if (p(h, i)) {
      var cell = {
        hd: h,
        tl: /* [] */0
      };
      copyAuxWithFilterIndex(p, t, cell, i + 1 | 0);
      return cell;
    }
    _i = i + 1 | 0;
    _xs = t;
    continue ;
  };
}

function keepWithIndex(xs, p) {
  return keepWithIndexU(xs, Curry.__2(p));
}

function keepMapU(_xs, p) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return /* [] */0;
    }
    var t = xs.tl;
    var h = p(xs.hd);
    if (h !== undefined) {
      var cell = {
        hd: Caml_option.valFromOption(h),
        tl: /* [] */0
      };
      copyAuxWitFilterMap(p, t, cell);
      return cell;
    }
    _xs = t;
    continue ;
  };
}

function keepMap(xs, p) {
  return keepMapU(xs, Curry.__1(p));
}

function partitionU(l, p) {
  if (!l) {
    return [
            /* [] */0,
            /* [] */0
          ];
  }
  var h = l.hd;
  var nextX = {
    hd: h,
    tl: /* [] */0
  };
  var nextY = {
    hd: h,
    tl: /* [] */0
  };
  var b = p(h);
  partitionAux(p, l.tl, nextX, nextY);
  if (b) {
    return [
            nextX,
            nextY.tl
          ];
  } else {
    return [
            nextX.tl,
            nextY
          ];
  }
}

function partition(l, p) {
  return partitionU(l, Curry.__1(p));
}

function unzip(xs) {
  if (!xs) {
    return [
            /* [] */0,
            /* [] */0
          ];
  }
  var match = xs.hd;
  var cellX = {
    hd: match[0],
    tl: /* [] */0
  };
  var cellY = {
    hd: match[1],
    tl: /* [] */0
  };
  splitAux(xs.tl, cellX, cellY);
  return [
          cellX,
          cellY
        ];
}

function zip(l1, l2) {
  if (!l1) {
    return /* [] */0;
  }
  if (!l2) {
    return /* [] */0;
  }
  var cell = {
    hd: [
      l1.hd,
      l2.hd
    ],
    tl: /* [] */0
  };
  zipAux(l1.tl, l2.tl, cell);
  return cell;
}

var size = length;

var filter = keep;

var filterWithIndex = keepWithIndex;

exports.length = length;
exports.size = size;
exports.head = head;
exports.headExn = headExn;
exports.tail = tail;
exports.tailExn = tailExn;
exports.add = add;
exports.get = get;
exports.getExn = getExn;
exports.make = make;
exports.makeByU = makeByU;
exports.makeBy = makeBy;
exports.shuffle = shuffle;
exports.drop = drop;
exports.take = take;
exports.splitAt = splitAt;
exports.concat = concat;
exports.concatMany = concatMany;
exports.reverseConcat = reverseConcat;
exports.flatten = flatten;
exports.mapU = mapU;
exports.map = map;
exports.zip = zip;
exports.zipByU = zipByU;
exports.zipBy = zipBy;
exports.mapWithIndexU = mapWithIndexU;
exports.mapWithIndex = mapWithIndex;
exports.fromArray = fromArray;
exports.toArray = toArray;
exports.reverse = reverse;
exports.mapReverseU = mapReverseU;
exports.mapReverse = mapReverse;
exports.forEachU = forEachU;
exports.forEach = forEach;
exports.forEachWithIndexU = forEachWithIndexU;
exports.forEachWithIndex = forEachWithIndex;
exports.reduceU = reduceU;
exports.reduce = reduce;
exports.reduceWithIndexU = reduceWithIndexU;
exports.reduceWithIndex = reduceWithIndex;
exports.reduceReverseU = reduceReverseU;
exports.reduceReverse = reduceReverse;
exports.mapReverse2U = mapReverse2U;
exports.mapReverse2 = mapReverse2;
exports.forEach2U = forEach2U;
exports.forEach2 = forEach2;
exports.reduce2U = reduce2U;
exports.reduce2 = reduce2;
exports.reduceReverse2U = reduceReverse2U;
exports.reduceReverse2 = reduceReverse2;
exports.everyU = everyU;
exports.every = every;
exports.someU = someU;
exports.some = some;
exports.every2U = every2U;
exports.every2 = every2;
exports.some2U = some2U;
exports.some2 = some2;
exports.cmpByLength = cmpByLength;
exports.cmpU = cmpU;
exports.cmp = cmp;
exports.eqU = eqU;
exports.eq = eq;
exports.hasU = hasU;
exports.has = has;
exports.getByU = getByU;
exports.getBy = getBy;
exports.keepU = keepU;
exports.keep = keep;
exports.filter = filter;
exports.keepWithIndexU = keepWithIndexU;
exports.keepWithIndex = keepWithIndex;
exports.filterWithIndex = filterWithIndex;
exports.keepMapU = keepMapU;
exports.keepMap = keepMap;
exports.partitionU = partitionU;
exports.partition = partition;
exports.unzip = unzip;
exports.getAssocU = getAssocU;
exports.getAssoc = getAssoc;
exports.hasAssocU = hasAssocU;
exports.hasAssoc = hasAssoc;
exports.removeAssocU = removeAssocU;
exports.removeAssoc = removeAssoc;
exports.setAssocU = setAssocU;
exports.setAssoc = setAssoc;
exports.sortU = sortU;
exports.sort = sort;
/* No side effect */


/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



var Caml = __webpack_require__(7);
var Curry = __webpack_require__(3);
var Js_math = __webpack_require__(8);
var Caml_option = __webpack_require__(10);

function get(arr, i) {
  if (i >= 0 && i < arr.length) {
    return Caml_option.some(arr[i]);
  }
  
}

function getExn(arr, i) {
  if (!(i >= 0 && i < arr.length)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "belt_Array.ml",
            27,
            4
          ],
          Error: new Error()
        };
  }
  return arr[i];
}

function set(arr, i, v) {
  if (i >= 0 && i < arr.length) {
    arr[i] = v;
    return true;
  } else {
    return false;
  }
}

function setExn(arr, i, v) {
  if (!(i >= 0 && i < arr.length)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "belt_Array.ml",
            33,
            2
          ],
          Error: new Error()
        };
  }
  arr[i] = v;
  
}

function swapUnsafe(xs, i, j) {
  var tmp = xs[i];
  xs[i] = xs[j];
  xs[j] = tmp;
  
}

function shuffleInPlace(xs) {
  var len = xs.length;
  for(var i = 0; i < len; ++i){
    swapUnsafe(xs, i, Js_math.random_int(i, len));
  }
  
}

function shuffle(xs) {
  var result = xs.slice(0);
  shuffleInPlace(result);
  return result;
}

function reverseInPlace(xs) {
  var len = xs.length;
  var ofs = 0;
  for(var i = 0 ,i_finish = len / 2 | 0; i < i_finish; ++i){
    swapUnsafe(xs, ofs + i | 0, ((ofs + len | 0) - i | 0) - 1 | 0);
  }
  
}

function reverse(xs) {
  var len = xs.length;
  var result = new Array(len);
  for(var i = 0; i < len; ++i){
    result[i] = xs[(len - 1 | 0) - i | 0];
  }
  return result;
}

function make(l, f) {
  if (l <= 0) {
    return [];
  }
  var res = new Array(l);
  for(var i = 0; i < l; ++i){
    res[i] = f;
  }
  return res;
}

function makeByU(l, f) {
  if (l <= 0) {
    return [];
  }
  var res = new Array(l);
  for(var i = 0; i < l; ++i){
    res[i] = f(i);
  }
  return res;
}

function makeBy(l, f) {
  return makeByU(l, Curry.__1(f));
}

function makeByAndShuffleU(l, f) {
  var u = makeByU(l, f);
  shuffleInPlace(u);
  return u;
}

function makeByAndShuffle(l, f) {
  return makeByAndShuffleU(l, Curry.__1(f));
}

function range(start, finish) {
  var cut = finish - start | 0;
  if (cut < 0) {
    return [];
  }
  var arr = new Array(cut + 1 | 0);
  for(var i = 0; i <= cut; ++i){
    arr[i] = start + i | 0;
  }
  return arr;
}

function rangeBy(start, finish, step) {
  var cut = finish - start | 0;
  if (cut < 0 || step <= 0) {
    return [];
  }
  var nb = (cut / step | 0) + 1 | 0;
  var arr = new Array(nb);
  var cur = start;
  for(var i = 0; i < nb; ++i){
    arr[i] = cur;
    cur = cur + step | 0;
  }
  return arr;
}

function zip(xs, ys) {
  var lenx = xs.length;
  var leny = ys.length;
  var len = lenx < leny ? lenx : leny;
  var s = new Array(len);
  for(var i = 0; i < len; ++i){
    s[i] = [
      xs[i],
      ys[i]
    ];
  }
  return s;
}

function zipByU(xs, ys, f) {
  var lenx = xs.length;
  var leny = ys.length;
  var len = lenx < leny ? lenx : leny;
  var s = new Array(len);
  for(var i = 0; i < len; ++i){
    s[i] = f(xs[i], ys[i]);
  }
  return s;
}

function zipBy(xs, ys, f) {
  return zipByU(xs, ys, Curry.__2(f));
}

function concat(a1, a2) {
  var l1 = a1.length;
  var l2 = a2.length;
  var a1a2 = new Array(l1 + l2 | 0);
  for(var i = 0; i < l1; ++i){
    a1a2[i] = a1[i];
  }
  for(var i$1 = 0; i$1 < l2; ++i$1){
    a1a2[l1 + i$1 | 0] = a2[i$1];
  }
  return a1a2;
}

function concatMany(arrs) {
  var lenArrs = arrs.length;
  var totalLen = 0;
  for(var i = 0; i < lenArrs; ++i){
    totalLen = totalLen + arrs[i].length | 0;
  }
  var result = new Array(totalLen);
  totalLen = 0;
  for(var j = 0; j < lenArrs; ++j){
    var cur = arrs[j];
    for(var k = 0 ,k_finish = cur.length; k < k_finish; ++k){
      result[totalLen] = cur[k];
      totalLen = totalLen + 1 | 0;
    }
  }
  return result;
}

function slice(a, offset, len) {
  if (len <= 0) {
    return [];
  }
  var lena = a.length;
  var ofs = offset < 0 ? Caml.caml_int_max(lena + offset | 0, 0) : offset;
  var hasLen = lena - ofs | 0;
  var copyLength = hasLen < len ? hasLen : len;
  if (copyLength <= 0) {
    return [];
  }
  var result = new Array(copyLength);
  for(var i = 0; i < copyLength; ++i){
    result[i] = a[ofs + i | 0];
  }
  return result;
}

function sliceToEnd(a, offset) {
  var lena = a.length;
  var ofs = offset < 0 ? Caml.caml_int_max(lena + offset | 0, 0) : offset;
  var len = lena - ofs | 0;
  var result = new Array(len);
  for(var i = 0; i < len; ++i){
    result[i] = a[ofs + i | 0];
  }
  return result;
}

function fill(a, offset, len, v) {
  if (len <= 0) {
    return ;
  }
  var lena = a.length;
  var ofs = offset < 0 ? Caml.caml_int_max(lena + offset | 0, 0) : offset;
  var hasLen = lena - ofs | 0;
  var fillLength = hasLen < len ? hasLen : len;
  if (fillLength <= 0) {
    return ;
  }
  for(var i = ofs ,i_finish = ofs + fillLength | 0; i < i_finish; ++i){
    a[i] = v;
  }
  
}

function blitUnsafe(a1, srcofs1, a2, srcofs2, blitLength) {
  if (srcofs2 <= srcofs1) {
    for(var j = 0; j < blitLength; ++j){
      a2[j + srcofs2 | 0] = a1[j + srcofs1 | 0];
    }
    return ;
  }
  for(var j$1 = blitLength - 1 | 0; j$1 >= 0; --j$1){
    a2[j$1 + srcofs2 | 0] = a1[j$1 + srcofs1 | 0];
  }
  
}

function blit(a1, ofs1, a2, ofs2, len) {
  var lena1 = a1.length;
  var lena2 = a2.length;
  var srcofs1 = ofs1 < 0 ? Caml.caml_int_max(lena1 + ofs1 | 0, 0) : ofs1;
  var srcofs2 = ofs2 < 0 ? Caml.caml_int_max(lena2 + ofs2 | 0, 0) : ofs2;
  var blitLength = Caml.caml_int_min(len, Caml.caml_int_min(lena1 - srcofs1 | 0, lena2 - srcofs2 | 0));
  if (srcofs2 <= srcofs1) {
    for(var j = 0; j < blitLength; ++j){
      a2[j + srcofs2 | 0] = a1[j + srcofs1 | 0];
    }
    return ;
  }
  for(var j$1 = blitLength - 1 | 0; j$1 >= 0; --j$1){
    a2[j$1 + srcofs2 | 0] = a1[j$1 + srcofs1 | 0];
  }
  
}

function forEachU(a, f) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    f(a[i]);
  }
  
}

function forEach(a, f) {
  return forEachU(a, Curry.__1(f));
}

function mapU(a, f) {
  var l = a.length;
  var r = new Array(l);
  for(var i = 0; i < l; ++i){
    r[i] = f(a[i]);
  }
  return r;
}

function map(a, f) {
  return mapU(a, Curry.__1(f));
}

function getByU(a, p) {
  var l = a.length;
  var i = 0;
  var r;
  while(r === undefined && i < l) {
    var v = a[i];
    if (p(v)) {
      r = Caml_option.some(v);
    }
    i = i + 1 | 0;
  };
  return r;
}

function getBy(a, p) {
  return getByU(a, Curry.__1(p));
}

function getIndexByU(a, p) {
  var l = a.length;
  var i = 0;
  var r;
  while(r === undefined && i < l) {
    var v = a[i];
    if (p(v)) {
      r = i;
    }
    i = i + 1 | 0;
  };
  return r;
}

function getIndexBy(a, p) {
  return getIndexByU(a, Curry.__1(p));
}

function keepU(a, f) {
  var l = a.length;
  var r = new Array(l);
  var j = 0;
  for(var i = 0; i < l; ++i){
    var v = a[i];
    if (f(v)) {
      r[j] = v;
      j = j + 1 | 0;
    }
    
  }
  r.length = j;
  return r;
}

function keep(a, f) {
  return keepU(a, Curry.__1(f));
}

function keepWithIndexU(a, f) {
  var l = a.length;
  var r = new Array(l);
  var j = 0;
  for(var i = 0; i < l; ++i){
    var v = a[i];
    if (f(v, i)) {
      r[j] = v;
      j = j + 1 | 0;
    }
    
  }
  r.length = j;
  return r;
}

function keepWithIndex(a, f) {
  return keepWithIndexU(a, Curry.__2(f));
}

function keepMapU(a, f) {
  var l = a.length;
  var r = new Array(l);
  var j = 0;
  for(var i = 0; i < l; ++i){
    var v = a[i];
    var v$1 = f(v);
    if (v$1 !== undefined) {
      r[j] = Caml_option.valFromOption(v$1);
      j = j + 1 | 0;
    }
    
  }
  r.length = j;
  return r;
}

function keepMap(a, f) {
  return keepMapU(a, Curry.__1(f));
}

function forEachWithIndexU(a, f) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    f(i, a[i]);
  }
  
}

function forEachWithIndex(a, f) {
  return forEachWithIndexU(a, Curry.__2(f));
}

function mapWithIndexU(a, f) {
  var l = a.length;
  var r = new Array(l);
  for(var i = 0; i < l; ++i){
    r[i] = f(i, a[i]);
  }
  return r;
}

function mapWithIndex(a, f) {
  return mapWithIndexU(a, Curry.__2(f));
}

function reduceU(a, x, f) {
  var r = x;
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    r = f(r, a[i]);
  }
  return r;
}

function reduce(a, x, f) {
  return reduceU(a, x, Curry.__2(f));
}

function reduceReverseU(a, x, f) {
  var r = x;
  for(var i = a.length - 1 | 0; i >= 0; --i){
    r = f(r, a[i]);
  }
  return r;
}

function reduceReverse(a, x, f) {
  return reduceReverseU(a, x, Curry.__2(f));
}

function reduceReverse2U(a, b, x, f) {
  var r = x;
  var len = Caml.caml_int_min(a.length, b.length);
  for(var i = len - 1 | 0; i >= 0; --i){
    r = f(r, a[i], b[i]);
  }
  return r;
}

function reduceReverse2(a, b, x, f) {
  return reduceReverse2U(a, b, x, Curry.__3(f));
}

function reduceWithIndexU(a, x, f) {
  var r = x;
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    r = f(r, a[i], i);
  }
  return r;
}

function reduceWithIndex(a, x, f) {
  return reduceWithIndexU(a, x, Curry.__3(f));
}

function everyU(arr, b) {
  var len = arr.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === len) {
      return true;
    }
    if (!b(arr[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function every(arr, f) {
  return everyU(arr, Curry.__1(f));
}

function someU(arr, b) {
  var len = arr.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === len) {
      return false;
    }
    if (b(arr[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function some(arr, f) {
  return someU(arr, Curry.__1(f));
}

function everyAux2(arr1, arr2, _i, b, len) {
  while(true) {
    var i = _i;
    if (i === len) {
      return true;
    }
    if (!b(arr1[i], arr2[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function every2U(a, b, p) {
  return everyAux2(a, b, 0, p, Caml.caml_int_min(a.length, b.length));
}

function every2(a, b, p) {
  return every2U(a, b, Curry.__2(p));
}

function some2U(a, b, p) {
  var _i = 0;
  var len = Caml.caml_int_min(a.length, b.length);
  while(true) {
    var i = _i;
    if (i === len) {
      return false;
    }
    if (p(a[i], b[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function some2(a, b, p) {
  return some2U(a, b, Curry.__2(p));
}

function eqU(a, b, p) {
  var lena = a.length;
  var lenb = b.length;
  if (lena === lenb) {
    return everyAux2(a, b, 0, p, lena);
  } else {
    return false;
  }
}

function eq(a, b, p) {
  return eqU(a, b, Curry.__2(p));
}

function cmpU(a, b, p) {
  var lena = a.length;
  var lenb = b.length;
  if (lena > lenb) {
    return 1;
  } else if (lena < lenb) {
    return -1;
  } else {
    var _i = 0;
    while(true) {
      var i = _i;
      if (i === lena) {
        return 0;
      }
      var c = p(a[i], b[i]);
      if (c !== 0) {
        return c;
      }
      _i = i + 1 | 0;
      continue ;
    };
  }
}

function cmp(a, b, p) {
  return cmpU(a, b, Curry.__2(p));
}

function partitionU(a, f) {
  var l = a.length;
  var i = 0;
  var j = 0;
  var a1 = new Array(l);
  var a2 = new Array(l);
  for(var ii = 0; ii < l; ++ii){
    var v = a[ii];
    if (f(v)) {
      a1[i] = v;
      i = i + 1 | 0;
    } else {
      a2[j] = v;
      j = j + 1 | 0;
    }
  }
  a1.length = i;
  a2.length = j;
  return [
          a1,
          a2
        ];
}

function partition(a, f) {
  return partitionU(a, Curry.__1(f));
}

function unzip(a) {
  var l = a.length;
  var a1 = new Array(l);
  var a2 = new Array(l);
  for(var i = 0; i < l; ++i){
    var match = a[i];
    a1[i] = match[0];
    a2[i] = match[1];
  }
  return [
          a1,
          a2
        ];
}

function joinWithU(a, sep, toString) {
  var l = a.length;
  if (l === 0) {
    return "";
  }
  var lastIndex = l - 1 | 0;
  var _i = 0;
  var _res = "";
  while(true) {
    var res = _res;
    var i = _i;
    if (i === lastIndex) {
      return res + toString(a[i]);
    }
    _res = res + (toString(a[i]) + sep);
    _i = i + 1 | 0;
    continue ;
  };
}

function joinWith(a, sep, toString) {
  return joinWithU(a, sep, Curry.__1(toString));
}

exports.get = get;
exports.getExn = getExn;
exports.set = set;
exports.setExn = setExn;
exports.shuffleInPlace = shuffleInPlace;
exports.shuffle = shuffle;
exports.reverseInPlace = reverseInPlace;
exports.reverse = reverse;
exports.make = make;
exports.range = range;
exports.rangeBy = rangeBy;
exports.makeByU = makeByU;
exports.makeBy = makeBy;
exports.makeByAndShuffleU = makeByAndShuffleU;
exports.makeByAndShuffle = makeByAndShuffle;
exports.zip = zip;
exports.zipByU = zipByU;
exports.zipBy = zipBy;
exports.unzip = unzip;
exports.concat = concat;
exports.concatMany = concatMany;
exports.slice = slice;
exports.sliceToEnd = sliceToEnd;
exports.fill = fill;
exports.blit = blit;
exports.blitUnsafe = blitUnsafe;
exports.forEachU = forEachU;
exports.forEach = forEach;
exports.mapU = mapU;
exports.map = map;
exports.getByU = getByU;
exports.getBy = getBy;
exports.getIndexByU = getIndexByU;
exports.getIndexBy = getIndexBy;
exports.keepU = keepU;
exports.keep = keep;
exports.keepWithIndexU = keepWithIndexU;
exports.keepWithIndex = keepWithIndex;
exports.keepMapU = keepMapU;
exports.keepMap = keepMap;
exports.forEachWithIndexU = forEachWithIndexU;
exports.forEachWithIndex = forEachWithIndex;
exports.mapWithIndexU = mapWithIndexU;
exports.mapWithIndex = mapWithIndex;
exports.partitionU = partitionU;
exports.partition = partition;
exports.reduceU = reduceU;
exports.reduce = reduce;
exports.reduceReverseU = reduceReverseU;
exports.reduceReverse = reduceReverse;
exports.reduceReverse2U = reduceReverse2U;
exports.reduceReverse2 = reduceReverse2;
exports.reduceWithIndexU = reduceWithIndexU;
exports.reduceWithIndex = reduceWithIndex;
exports.joinWithU = joinWithU;
exports.joinWith = joinWith;
exports.someU = someU;
exports.some = some;
exports.everyU = everyU;
exports.every = every;
exports.every2U = every2U;
exports.every2 = every2;
exports.some2U = some2U;
exports.some2 = some2;
exports.cmpU = cmpU;
exports.cmp = cmp;
exports.eqU = eqU;
exports.eq = eq;
/* No side effect */


/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, exports) => {




function caml_int_compare(x, y) {
  if (x < y) {
    return -1;
  } else if (x === y) {
    return 0;
  } else {
    return 1;
  }
}

function caml_bool_compare(x, y) {
  if (x) {
    if (y) {
      return 0;
    } else {
      return 1;
    }
  } else if (y) {
    return -1;
  } else {
    return 0;
  }
}

function caml_float_compare(x, y) {
  if (x === y) {
    return 0;
  } else if (x < y) {
    return -1;
  } else if (x > y || x === x) {
    return 1;
  } else if (y === y) {
    return -1;
  } else {
    return 0;
  }
}

function caml_string_compare(s1, s2) {
  if (s1 === s2) {
    return 0;
  } else if (s1 < s2) {
    return -1;
  } else {
    return 1;
  }
}

function caml_bool_min(x, y) {
  if (x) {
    return y;
  } else {
    return x;
  }
}

function caml_int_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_float_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_string_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_int32_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_bool_max(x, y) {
  if (x) {
    return x;
  } else {
    return y;
  }
}

function caml_int_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_float_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_string_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_int32_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function i64_eq(x, y) {
  if (x[1] === y[1]) {
    return x[0] === y[0];
  } else {
    return false;
  }
}

function i64_ge(param, param$1) {
  var other_hi = param$1[0];
  var hi = param[0];
  if (hi > other_hi) {
    return true;
  } else if (hi < other_hi) {
    return false;
  } else {
    return param[1] >= param$1[1];
  }
}

function i64_neq(x, y) {
  return !i64_eq(x, y);
}

function i64_lt(x, y) {
  return !i64_ge(x, y);
}

function i64_gt(x, y) {
  if (x[0] > y[0]) {
    return true;
  } else if (x[0] < y[0]) {
    return false;
  } else {
    return x[1] > y[1];
  }
}

function i64_le(x, y) {
  return !i64_gt(x, y);
}

function i64_min(x, y) {
  if (i64_ge(x, y)) {
    return y;
  } else {
    return x;
  }
}

function i64_max(x, y) {
  if (i64_gt(x, y)) {
    return x;
  } else {
    return y;
  }
}

exports.caml_int_compare = caml_int_compare;
exports.caml_bool_compare = caml_bool_compare;
exports.caml_float_compare = caml_float_compare;
exports.caml_string_compare = caml_string_compare;
exports.caml_bool_min = caml_bool_min;
exports.caml_int_min = caml_int_min;
exports.caml_float_min = caml_float_min;
exports.caml_string_min = caml_string_min;
exports.caml_int32_min = caml_int32_min;
exports.caml_bool_max = caml_bool_max;
exports.caml_int_max = caml_int_max;
exports.caml_float_max = caml_float_max;
exports.caml_string_max = caml_string_max;
exports.caml_int32_max = caml_int32_max;
exports.i64_eq = i64_eq;
exports.i64_neq = i64_neq;
exports.i64_lt = i64_lt;
exports.i64_gt = i64_gt;
exports.i64_le = i64_le;
exports.i64_ge = i64_ge;
exports.i64_min = i64_min;
exports.i64_max = i64_max;
/* No side effect */


/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



var Js_int = __webpack_require__(9);

function unsafe_ceil(prim) {
  return Math.ceil(prim);
}

function ceil_int(f) {
  if (f > Js_int.max) {
    return Js_int.max;
  } else if (f < Js_int.min) {
    return Js_int.min;
  } else {
    return Math.ceil(f);
  }
}

function unsafe_floor(prim) {
  return Math.floor(prim);
}

function floor_int(f) {
  if (f > Js_int.max) {
    return Js_int.max;
  } else if (f < Js_int.min) {
    return Js_int.min;
  } else {
    return Math.floor(f);
  }
}

function random_int(min, max) {
  return floor_int(Math.random() * (max - min | 0)) + min | 0;
}

var ceil = ceil_int;

var floor = floor_int;

exports.unsafe_ceil = unsafe_ceil;
exports.ceil_int = ceil_int;
exports.ceil = ceil;
exports.unsafe_floor = unsafe_floor;
exports.floor_int = floor_int;
exports.floor = floor;
exports.random_int = random_int;
/* No side effect */


/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, exports) => {




function equal(x, y) {
  return x === y;
}

var max = 2147483647;

var min = -2147483648;

exports.equal = equal;
exports.max = max;
exports.min = min;
/* No side effect */


/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, exports) => {




function isNested(x) {
  return x.BS_PRIVATE_NESTED_SOME_NONE !== undefined;
}

function some(x) {
  if (x === undefined) {
    return {
            BS_PRIVATE_NESTED_SOME_NONE: 0
          };
  } else if (x !== null && x.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {
    return {
            BS_PRIVATE_NESTED_SOME_NONE: x.BS_PRIVATE_NESTED_SOME_NONE + 1 | 0
          };
  } else {
    return x;
  }
}

function nullable_to_opt(x) {
  if (x == null) {
    return ;
  } else {
    return some(x);
  }
}

function undefined_to_opt(x) {
  if (x === undefined) {
    return ;
  } else {
    return some(x);
  }
}

function null_to_opt(x) {
  if (x === null) {
    return ;
  } else {
    return some(x);
  }
}

function valFromOption(x) {
  if (!(x !== null && x.BS_PRIVATE_NESTED_SOME_NONE !== undefined)) {
    return x;
  }
  var depth = x.BS_PRIVATE_NESTED_SOME_NONE;
  if (depth === 0) {
    return ;
  } else {
    return {
            BS_PRIVATE_NESTED_SOME_NONE: depth - 1 | 0
          };
  }
}

function option_get(x) {
  if (x === undefined) {
    return ;
  } else {
    return valFromOption(x);
  }
}

function option_unwrap(x) {
  if (x !== undefined) {
    return x.VAL;
  } else {
    return x;
  }
}

exports.nullable_to_opt = nullable_to_opt;
exports.undefined_to_opt = undefined_to_opt;
exports.null_to_opt = null_to_opt;
exports.valFromOption = valFromOption;
exports.some = some;
exports.isNested = isNested;
exports.option_get = option_get;
exports.option_unwrap = option_unwrap;
/* No side effect */


/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



var Curry = __webpack_require__(3);
var Belt_Array = __webpack_require__(6);

function sortedLengthAuxMore(xs, _prec, _acc, len, lt) {
  while(true) {
    var acc = _acc;
    var prec = _prec;
    if (acc >= len) {
      return acc;
    }
    var v = xs[acc];
    if (!lt(v, prec)) {
      return acc;
    }
    _acc = acc + 1 | 0;
    _prec = v;
    continue ;
  };
}

function strictlySortedLengthU(xs, lt) {
  var len = xs.length;
  if (len === 0 || len === 1) {
    return len;
  }
  var x0 = xs[0];
  var x1 = xs[1];
  if (lt(x0, x1)) {
    var _prec = x1;
    var _acc = 2;
    while(true) {
      var acc = _acc;
      var prec = _prec;
      if (acc >= len) {
        return acc;
      }
      var v = xs[acc];
      if (!lt(prec, v)) {
        return acc;
      }
      _acc = acc + 1 | 0;
      _prec = v;
      continue ;
    };
  } else if (lt(x1, x0)) {
    return -sortedLengthAuxMore(xs, x1, 2, len, lt) | 0;
  } else {
    return 1;
  }
}

function strictlySortedLength(xs, lt) {
  return strictlySortedLengthU(xs, Curry.__2(lt));
}

function isSortedU(a, cmp) {
  var len = a.length;
  if (len === 0) {
    return true;
  } else {
    var _i = 0;
    var last_bound = len - 1 | 0;
    while(true) {
      var i = _i;
      if (i === last_bound) {
        return true;
      }
      if (cmp(a[i], a[i + 1 | 0]) > 0) {
        return false;
      }
      _i = i + 1 | 0;
      continue ;
    };
  }
}

function isSorted(a, cmp) {
  return isSortedU(a, Curry.__2(cmp));
}

function merge(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  var src1r = src1ofs + src1len | 0;
  var src2r = src2ofs + src2len | 0;
  var _i1 = src1ofs;
  var _s1 = src[src1ofs];
  var _i2 = src2ofs;
  var _s2 = src2[src2ofs];
  var _d = dstofs;
  while(true) {
    var d = _d;
    var s2 = _s2;
    var i2 = _i2;
    var s1 = _s1;
    var i1 = _i1;
    if (cmp(s1, s2) <= 0) {
      dst[d] = s1;
      var i1$1 = i1 + 1 | 0;
      if (i1$1 >= src1r) {
        return Belt_Array.blitUnsafe(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
      }
      _d = d + 1 | 0;
      _s1 = src[i1$1];
      _i1 = i1$1;
      continue ;
    }
    dst[d] = s2;
    var i2$1 = i2 + 1 | 0;
    if (i2$1 >= src2r) {
      return Belt_Array.blitUnsafe(src, i1, dst, d + 1 | 0, src1r - i1 | 0);
    }
    _d = d + 1 | 0;
    _s2 = src2[i2$1];
    _i2 = i2$1;
    continue ;
  };
}

function unionU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  var src1r = src1ofs + src1len | 0;
  var src2r = src2ofs + src2len | 0;
  var _i1 = src1ofs;
  var _s1 = src[src1ofs];
  var _i2 = src2ofs;
  var _s2 = src2[src2ofs];
  var _d = dstofs;
  while(true) {
    var d = _d;
    var s2 = _s2;
    var i2 = _i2;
    var s1 = _s1;
    var i1 = _i1;
    var c = cmp(s1, s2);
    if (c < 0) {
      dst[d] = s1;
      var i1$1 = i1 + 1 | 0;
      var d$1 = d + 1 | 0;
      if (i1$1 < src1r) {
        _d = d$1;
        _s1 = src[i1$1];
        _i1 = i1$1;
        continue ;
      }
      Belt_Array.blitUnsafe(src2, i2, dst, d$1, src2r - i2 | 0);
      return (d$1 + src2r | 0) - i2 | 0;
    }
    if (c === 0) {
      dst[d] = s1;
      var i1$2 = i1 + 1 | 0;
      var i2$1 = i2 + 1 | 0;
      var d$2 = d + 1 | 0;
      if (!(i1$2 < src1r && i2$1 < src2r)) {
        if (i1$2 === src1r) {
          Belt_Array.blitUnsafe(src2, i2$1, dst, d$2, src2r - i2$1 | 0);
          return (d$2 + src2r | 0) - i2$1 | 0;
        } else {
          Belt_Array.blitUnsafe(src, i1$2, dst, d$2, src1r - i1$2 | 0);
          return (d$2 + src1r | 0) - i1$2 | 0;
        }
      }
      _d = d$2;
      _s2 = src2[i2$1];
      _i2 = i2$1;
      _s1 = src[i1$2];
      _i1 = i1$2;
      continue ;
    }
    dst[d] = s2;
    var i2$2 = i2 + 1 | 0;
    var d$3 = d + 1 | 0;
    if (i2$2 < src2r) {
      _d = d$3;
      _s2 = src2[i2$2];
      _i2 = i2$2;
      continue ;
    }
    Belt_Array.blitUnsafe(src, i1, dst, d$3, src1r - i1 | 0);
    return (d$3 + src1r | 0) - i1 | 0;
  };
}

function union(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  return unionU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, Curry.__2(cmp));
}

function intersectU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  var src1r = src1ofs + src1len | 0;
  var src2r = src2ofs + src2len | 0;
  var _i1 = src1ofs;
  var _s1 = src[src1ofs];
  var _i2 = src2ofs;
  var _s2 = src2[src2ofs];
  var _d = dstofs;
  while(true) {
    var d = _d;
    var s2 = _s2;
    var i2 = _i2;
    var s1 = _s1;
    var i1 = _i1;
    var c = cmp(s1, s2);
    if (c < 0) {
      var i1$1 = i1 + 1 | 0;
      if (i1$1 >= src1r) {
        return d;
      }
      _s1 = src[i1$1];
      _i1 = i1$1;
      continue ;
    }
    if (c === 0) {
      dst[d] = s1;
      var i1$2 = i1 + 1 | 0;
      var i2$1 = i2 + 1 | 0;
      var d$1 = d + 1 | 0;
      if (!(i1$2 < src1r && i2$1 < src2r)) {
        return d$1;
      }
      _d = d$1;
      _s2 = src2[i2$1];
      _i2 = i2$1;
      _s1 = src[i1$2];
      _i1 = i1$2;
      continue ;
    }
    var i2$2 = i2 + 1 | 0;
    if (i2$2 >= src2r) {
      return d;
    }
    _s2 = src2[i2$2];
    _i2 = i2$2;
    continue ;
  };
}

function intersect(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  return intersectU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, Curry.__2(cmp));
}

function diffU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  var src1r = src1ofs + src1len | 0;
  var src2r = src2ofs + src2len | 0;
  var _i1 = src1ofs;
  var _s1 = src[src1ofs];
  var _i2 = src2ofs;
  var _s2 = src2[src2ofs];
  var _d = dstofs;
  while(true) {
    var d = _d;
    var s2 = _s2;
    var i2 = _i2;
    var s1 = _s1;
    var i1 = _i1;
    var c = cmp(s1, s2);
    if (c < 0) {
      dst[d] = s1;
      var d$1 = d + 1 | 0;
      var i1$1 = i1 + 1 | 0;
      if (i1$1 >= src1r) {
        return d$1;
      }
      _d = d$1;
      _s1 = src[i1$1];
      _i1 = i1$1;
      continue ;
    }
    if (c === 0) {
      var i1$2 = i1 + 1 | 0;
      var i2$1 = i2 + 1 | 0;
      if (!(i1$2 < src1r && i2$1 < src2r)) {
        if (i1$2 === src1r) {
          return d;
        } else {
          Belt_Array.blitUnsafe(src, i1$2, dst, d, src1r - i1$2 | 0);
          return (d + src1r | 0) - i1$2 | 0;
        }
      }
      _s2 = src2[i2$1];
      _i2 = i2$1;
      _s1 = src[i1$2];
      _i1 = i1$2;
      continue ;
    }
    var i2$2 = i2 + 1 | 0;
    if (i2$2 < src2r) {
      _s2 = src2[i2$2];
      _i2 = i2$2;
      continue ;
    }
    Belt_Array.blitUnsafe(src, i1, dst, d, src1r - i1 | 0);
    return (d + src1r | 0) - i1 | 0;
  };
}

function diff(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  return diffU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, Curry.__2(cmp));
}

function insertionSort(src, srcofs, dst, dstofs, len, cmp) {
  for(var i = 0; i < len; ++i){
    var e = src[srcofs + i | 0];
    var j = (dstofs + i | 0) - 1 | 0;
    while(j >= dstofs && cmp(dst[j], e) > 0) {
      dst[j + 1 | 0] = dst[j];
      j = j - 1 | 0;
    };
    dst[j + 1 | 0] = e;
  }
  
}

function sortTo(src, srcofs, dst, dstofs, len, cmp) {
  if (len <= 5) {
    return insertionSort(src, srcofs, dst, dstofs, len, cmp);
  }
  var l1 = len / 2 | 0;
  var l2 = len - l1 | 0;
  sortTo(src, srcofs + l1 | 0, dst, dstofs + l1 | 0, l2, cmp);
  sortTo(src, srcofs, src, srcofs + l2 | 0, l1, cmp);
  return merge(src, srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs, cmp);
}

function stableSortInPlaceByU(a, cmp) {
  var l = a.length;
  if (l <= 5) {
    return insertionSort(a, 0, a, 0, l, cmp);
  }
  var l1 = l / 2 | 0;
  var l2 = l - l1 | 0;
  var t = new Array(l2);
  sortTo(a, l1, t, 0, l2, cmp);
  sortTo(a, 0, a, l2, l1, cmp);
  return merge(a, l2, l1, t, 0, l2, a, 0, cmp);
}

function stableSortInPlaceBy(a, cmp) {
  return stableSortInPlaceByU(a, Curry.__2(cmp));
}

function stableSortByU(a, cmp) {
  var b = a.slice(0);
  stableSortInPlaceByU(b, cmp);
  return b;
}

function stableSortBy(a, cmp) {
  return stableSortByU(a, Curry.__2(cmp));
}

function binarySearchByU(sorted, key, cmp) {
  var len = sorted.length;
  if (len === 0) {
    return -1;
  }
  var lo = sorted[0];
  var c = cmp(key, lo);
  if (c < 0) {
    return -1;
  }
  var hi = sorted[len - 1 | 0];
  var c2 = cmp(key, hi);
  if (c2 > 0) {
    return -(len + 1 | 0) | 0;
  } else {
    var _lo = 0;
    var _hi = len - 1 | 0;
    while(true) {
      var hi$1 = _hi;
      var lo$1 = _lo;
      var mid = (lo$1 + hi$1 | 0) / 2 | 0;
      var midVal = sorted[mid];
      var c$1 = cmp(key, midVal);
      if (c$1 === 0) {
        return mid;
      }
      if (c$1 < 0) {
        if (hi$1 === mid) {
          if (cmp(sorted[lo$1], key) === 0) {
            return lo$1;
          } else {
            return -(hi$1 + 1 | 0) | 0;
          }
        }
        _hi = mid;
        continue ;
      }
      if (lo$1 === mid) {
        if (cmp(sorted[hi$1], key) === 0) {
          return hi$1;
        } else {
          return -(hi$1 + 1 | 0) | 0;
        }
      }
      _lo = mid;
      continue ;
    };
  }
}

function binarySearchBy(sorted, key, cmp) {
  return binarySearchByU(sorted, key, Curry.__2(cmp));
}

var Int;

var $$String;

exports.Int = Int;
exports.$$String = $$String;
exports.strictlySortedLengthU = strictlySortedLengthU;
exports.strictlySortedLength = strictlySortedLength;
exports.isSortedU = isSortedU;
exports.isSorted = isSorted;
exports.stableSortInPlaceByU = stableSortInPlaceByU;
exports.stableSortInPlaceBy = stableSortInPlaceBy;
exports.stableSortByU = stableSortByU;
exports.stableSortBy = stableSortBy;
exports.binarySearchByU = binarySearchByU;
exports.binarySearchBy = binarySearchBy;
exports.unionU = unionU;
exports.union = union;
exports.intersectU = intersectU;
exports.intersect = intersect;
exports.diffU = diffU;
exports.diff = diff;
/* No side effect */


/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Generated by ReScript, PLEASE EDIT WITH CARE


var Board = __webpack_require__(2);
var Utils = __webpack_require__(1);
var Belt_List = __webpack_require__(5);

function canCover(piece, board, position) {
  var p = Board.getPiece(board, position, undefined);
  if (p !== undefined && (p.TAG === /* King */1 || Utils.getColor(p) === piece.color)) {
    return true;
  } else {
    return Board.checkUnobstructed(board, piece, position, false);
  }
}

function getUnobstructedCardinalPositions(piece, board) {
  var up = Belt_List.sort(Belt_List.keep(board.pieces, (function (p) {
              if (Utils.getX(p) === piece.x) {
                return Utils.getY(p) > piece.y;
              } else {
                return false;
              }
            })), (function (a, b) {
          return Utils.getY(a) - Utils.getY(b) | 0;
        }));
  var down = Belt_List.sort(Belt_List.keep(board.pieces, (function (p) {
              if (Utils.getX(p) === piece.x) {
                return Utils.getY(p) < piece.y;
              } else {
                return false;
              }
            })), (function (a, b) {
          return Utils.getY(b) - Utils.getY(a) | 0;
        }));
  var left = Belt_List.sort(Belt_List.keep(board.pieces, (function (p) {
              if (Utils.getY(p) === piece.y) {
                return Utils.getX(p) < piece.x;
              } else {
                return false;
              }
            })), (function (a, b) {
          return Utils.getX(b) - Utils.getX(a) | 0;
        }));
  var right = Belt_List.sort(Belt_List.keep(board.pieces, (function (p) {
              if (Utils.getY(p) === piece.y) {
                return Utils.getX(p) > piece.x;
              } else {
                return false;
              }
            })), (function (a, b) {
          return Utils.getX(a) - Utils.getX(b) | 0;
        }));
  var positionHelper = function (acc, position) {
    if (!acc[0]) {
      return [
              false,
              acc[1]
            ];
    }
    var lst = acc[1];
    if (canCover(piece, board, position)) {
      if (Board.hasPiece(board, position, undefined)) {
        return [
                false,
                {
                  hd: position,
                  tl: lst
                }
              ];
      } else {
        return [
                true,
                {
                  hd: position,
                  tl: lst
                }
              ];
      }
    } else {
      return [
              false,
              lst
            ];
    }
  };
  return Belt_List.flatten(Belt_List.map({
                  hd: up,
                  tl: {
                    hd: down,
                    tl: {
                      hd: left,
                      tl: {
                        hd: right,
                        tl: /* [] */0
                      }
                    }
                  }
                }, (function (l) {
                    return Belt_List.reduce(Belt_List.map(l, (function (i) {
                                        return [
                                                Utils.getX(i),
                                                Utils.getY(i)
                                              ];
                                      })), [
                                  true,
                                  /* [] */0
                                ], positionHelper)[1];
                  })));
}

function getUnobstructedDiagonalPositions(piece, board) {
  var ul = Belt_List.sort(Belt_List.keep(board.pieces, (function (p) {
              if (Utils.getX(p) < piece.x && Utils.getY(p) > piece.y) {
                return (Utils.getX(p) - Utils.getY(p) | 0) === (piece.x - piece.y | 0);
              } else {
                return false;
              }
            })), (function (a, b) {
          return Utils.getY(a) - Utils.getY(b) | 0;
        }));
  var ur = Belt_List.sort(Belt_List.keep(board.pieces, (function (p) {
              if (Utils.getX(p) > piece.x && Utils.getY(p) > piece.y) {
                return (Utils.getX(p) - Utils.getY(p) | 0) === (piece.x - piece.y | 0);
              } else {
                return false;
              }
            })), (function (a, b) {
          return Utils.getY(a) - Utils.getY(b) | 0;
        }));
  var dl = Belt_List.sort(Belt_List.keep(board.pieces, (function (p) {
              if (Utils.getX(p) < piece.x && Utils.getY(p) < piece.y) {
                return (Utils.getX(p) - Utils.getY(p) | 0) === (piece.x - piece.y | 0);
              } else {
                return false;
              }
            })), (function (a, b) {
          return Utils.getY(b) - Utils.getY(a) | 0;
        }));
  var dr = Belt_List.sort(Belt_List.keep(board.pieces, (function (p) {
              if (Utils.getX(p) > piece.x && Utils.getY(p) < piece.y) {
                return (Utils.getX(p) - Utils.getY(p) | 0) === (piece.x - piece.y | 0);
              } else {
                return false;
              }
            })), (function (a, b) {
          return Utils.getY(b) - Utils.getY(a) | 0;
        }));
  var positionHelper = function (acc, position) {
    if (!acc[0]) {
      return [
              false,
              acc[1]
            ];
    }
    var lst = acc[1];
    if (canCover(piece, board, position)) {
      if (Board.hasPiece(board, position, undefined)) {
        return [
                false,
                {
                  hd: position,
                  tl: lst
                }
              ];
      } else {
        return [
                true,
                {
                  hd: position,
                  tl: lst
                }
              ];
      }
    } else {
      return [
              false,
              lst
            ];
    }
  };
  return Belt_List.flatten(Belt_List.map({
                  hd: ul,
                  tl: {
                    hd: ur,
                    tl: {
                      hd: dl,
                      tl: {
                        hd: dr,
                        tl: /* [] */0
                      }
                    }
                  }
                }, (function (l) {
                    return Belt_List.reduce(Belt_List.map(l, (function (i) {
                                        return [
                                                Utils.getX(i),
                                                Utils.getY(i)
                                              ];
                                      })), [
                                  true,
                                  /* [] */0
                                ], positionHelper)[1];
                  })));
}

function getCoveredPositions(piece, board) {
  switch (piece.TAG | 0) {
    case /* Pawn */0 :
        var p = piece._0;
        var positions_0 = [
          p.x - 1 | 0,
          p.y + Utils.pawnOffsetHelper(p, 1) | 0
        ];
        var positions_1 = {
          hd: [
            p.x + 1 | 0,
            p.y + Utils.pawnOffsetHelper(p, 1) | 0
          ],
          tl: /* [] */0
        };
        var positions = {
          hd: positions_0,
          tl: positions_1
        };
        return Belt_List.keep(positions, (function (param) {
                      var y = param[1];
                      if (y >= 0 && y <= 7) {
                        return canCover(p, board, [
                                    param[0],
                                    y
                                  ]);
                      } else {
                        return false;
                      }
                    }));
    case /* King */1 :
        var k = piece._0;
        var positions_0$1 = [
          k.x - 1 | 0,
          k.y
        ];
        var positions_1$1 = {
          hd: [
            k.x - 1 | 0,
            k.y - 1 | 0
          ],
          tl: {
            hd: [
              k.x - 1 | 0,
              k.y + 1 | 0
            ],
            tl: {
              hd: [
                k.x,
                k.y - 1 | 0
              ],
              tl: {
                hd: [
                  k.x,
                  k.y + 1 | 0
                ],
                tl: {
                  hd: [
                    k.x + 1 | 0,
                    k.y
                  ],
                  tl: {
                    hd: [
                      k.x + 1 | 0,
                      k.y - 1 | 0
                    ],
                    tl: {
                      hd: [
                        k.x + 1 | 0,
                        k.y + 1 | 0
                      ],
                      tl: /* [] */0
                    }
                  }
                }
              }
            }
          }
        };
        var positions$1 = {
          hd: positions_0$1,
          tl: positions_1$1
        };
        return Belt_List.keep(positions$1, (function (p) {
                      return canCover(k, board, p);
                    }));
    case /* Queen */2 :
        var q = piece._0;
        return Belt_List.concat(getUnobstructedDiagonalPositions(q, board), getUnobstructedCardinalPositions(q, board));
    case /* Bishop */3 :
        return getUnobstructedDiagonalPositions(piece._0, board);
    case /* Knight */4 :
        var n = piece._0;
        var positions_0$2 = [
          n.x - 2 | 0,
          n.y - 1 | 0
        ];
        var positions_1$2 = {
          hd: [
            n.x - 2 | 0,
            n.y + 1 | 0
          ],
          tl: {
            hd: [
              n.x - 1 | 0,
              n.y + 2 | 0
            ],
            tl: {
              hd: [
                n.x - 1 | 0,
                n.y - 2 | 0
              ],
              tl: {
                hd: [
                  n.x + 1 | 0,
                  n.y + 2 | 0
                ],
                tl: {
                  hd: [
                    n.x + 1 | 0,
                    n.y - 2 | 0
                  ],
                  tl: {
                    hd: [
                      n.x + 2 | 0,
                      n.y - 1 | 0
                    ],
                    tl: {
                      hd: [
                        n.x + 2 | 0,
                        n.y + 1 | 0
                      ],
                      tl: /* [] */0
                    }
                  }
                }
              }
            }
          }
        };
        var positions$2 = {
          hd: positions_0$2,
          tl: positions_1$2
        };
        return Belt_List.keep(positions$2, (function (p) {
                      return canCover(n, board, p);
                    }));
    case /* Rook */5 :
        return getUnobstructedCardinalPositions(piece._0, board);
    
  }
}

function getCoveredPositionsForColor(board, color) {
  return coveredPositionsHelper(Belt_List.keep(board.pieces, (function (p) {
                    return Utils.getColor(p) === color;
                  })), board);
}

function coveredPositionsHelper(pieces, board) {
  return Belt_List.reduce(Belt_List.sort(Belt_List.flatten(Belt_List.reduce(pieces, /* [] */0, (function (acc, p) {
                            return {
                                    hd: getCoveredPositions(p, board),
                                    tl: acc
                                  };
                          }))), (function (param, param$1) {
                    var x2 = param$1[0];
                    var x1 = param[0];
                    if (x1 === x2) {
                      return param[1] - param$1[1] | 0;
                    } else {
                      return x1 - x2 | 0;
                    }
                  })), /* [] */0, (function (acc, param) {
                var y1 = param[1];
                var x1 = param[0];
                if (!acc) {
                  return {
                          hd: [
                            x1,
                            y1
                          ],
                          tl: /* [] */0
                        };
                }
                var match = acc.hd;
                if (x1 === match[0] && y1 === match[1]) {
                  return acc;
                } else {
                  return {
                          hd: [
                            x1,
                            y1
                          ],
                          tl: acc
                        };
                }
              }));
}

function validBoard(board, movedColor) {
  var ownKing = Belt_List.getExn(Belt_List.keep(board.pieces, (function (p) {
              if (p.TAG === /* King */1) {
                return true;
              } else {
                return false;
              }
            })), 1);
  var otherCoveredPositions = getCoveredPositionsForColor(board, Utils.oppositeColor(movedColor));
  return !Belt_List.has(otherCoveredPositions, [
              Utils.getX(ownKing),
              Utils.getY(ownKing)
            ], (function (param, param$1) {
                if (param[0] === param$1[0]) {
                  return param[1] === param$1[1];
                } else {
                  return false;
                }
              }));
}

function validStateForMove(board, piece, position) {
  var newBoard = Board.confirmMove(board, piece, position);
  return validBoard(newBoard, Utils.getColor(piece));
}

function getLegalMoves(piece, board) {
  switch (piece.TAG | 0) {
    case /* Pawn */0 :
        var p = piece._0;
        var oneSpace_0 = p.x;
        var oneSpace_1 = p.y + Utils.pawnOffsetHelper(p, 1) | 0;
        var oneSpace = [
          oneSpace_0,
          oneSpace_1
        ];
        var twoSpace_0 = p.x;
        var twoSpace_1 = p.y + Utils.pawnOffsetHelper(p, 2) | 0;
        var twoSpace = [
          twoSpace_0,
          twoSpace_1
        ];
        var movement = Board.checkUnobstructed(board, p, oneSpace, false) ? (
            p.hasMoved && Board.checkUnobstructed(board, p, twoSpace, false) ? ({
                  hd: oneSpace,
                  tl: {
                    hd: twoSpace,
                    tl: /* [] */0
                  }
                }) : ({
                  hd: oneSpace,
                  tl: /* [] */0
                })
          ) : /* [] */0;
        var capture = Belt_List.keep(getCoveredPositions(piece, board), (function (pos) {
                if (Board.hasOppositeColoredPiece(board, pos, p.color)) {
                  return true;
                }
                var otherPiece = Board.getPiece(board, [
                      pos[0],
                      p.y
                    ], Utils.oppositeColor(p.color));
                if (otherPiece !== undefined && otherPiece.TAG === /* Pawn */0) {
                  return otherPiece._0.hasJustMoved2Spaces;
                } else {
                  return false;
                }
              }));
        return Belt_List.keep(Belt_List.concat(movement, capture), (function (pos) {
                      return validStateForMove(board, {
                                  TAG: /* Pawn */0,
                                  _0: p
                                }, pos);
                    }));
    case /* King */1 :
        var k = piece._0;
        var regularMoves = Belt_List.keep(getCoveredPositions(piece, board), (function (p) {
                return validStateForMove(board, piece, p);
              }));
        if (k.hasMoved || k.inCheck) {
          return regularMoves;
        }
        var match = k.color;
        var y = match ? 7 : 0;
        var leftRook = Board.getPiece(board, [
              0,
              y
            ], k.color);
        var rightRook = Board.getPiece(board, [
              7,
              y
            ], k.color);
        var leftCastle = leftRook !== undefined && leftRook.TAG === /* Rook */5 && !(leftRook._0.hasMoved || Board.hasPiece(board, [
                1,
                y
              ], undefined) || Board.hasPiece(board, [
                2,
                y
              ], undefined) || Board.hasPiece(board, [
                3,
                y
              ], undefined) || !validStateForMove(board, piece, [
                3,
                y
              ]) || !validStateForMove(board, piece, [
                2,
                y
              ]) || !validStateForMove(board, piece, [
                2,
                y
              ])) ? [
            2,
            y
          ] : undefined;
        var rightCastle = rightRook !== undefined && rightRook.TAG === /* Rook */5 && !(rightRook._0.hasMoved || Board.hasPiece(board, [
                5,
                y
              ], undefined) || Board.hasPiece(board, [
                6,
                y
              ], undefined) || !validStateForMove(board, piece, [
                5,
                y
              ]) || !validStateForMove(board, piece, [
                6,
                y
              ]) || !validStateForMove(board, piece, [
                6,
                y
              ])) ? [
            6,
            y
          ] : undefined;
        if (leftCastle !== undefined) {
          if (rightCastle !== undefined) {
            return {
                    hd: leftCastle,
                    tl: {
                      hd: rightCastle,
                      tl: regularMoves
                    }
                  };
          } else {
            return {
                    hd: leftCastle,
                    tl: regularMoves
                  };
          }
        } else if (rightCastle !== undefined) {
          return {
                  hd: rightCastle,
                  tl: regularMoves
                };
        } else {
          return regularMoves;
        }
    default:
      return Belt_List.keep(getCoveredPositions(piece, board), (function (pos) {
                    return validStateForMove(board, piece, pos);
                  }));
  }
}

function getEmphasizedCoveredPositionsForColor(board, color) {
  return coveredPositionsHelper(Belt_List.keep(board.pieces, (function (p) {
                    if (Utils.getColor(p) === color) {
                      return Utils.getEmphasis(p);
                    } else {
                      return false;
                    }
                  })), board);
}

exports.canCover = canCover;
exports.getUnobstructedCardinalPositions = getUnobstructedCardinalPositions;
exports.getUnobstructedDiagonalPositions = getUnobstructedDiagonalPositions;
exports.getCoveredPositions = getCoveredPositions;
exports.validStateForMove = validStateForMove;
exports.getLegalMoves = getLegalMoves;
exports.coveredPositionsHelper = coveredPositionsHelper;
exports.getCoveredPositionsForColor = getCoveredPositionsForColor;
exports.validBoard = validBoard;
exports.getEmphasizedCoveredPositionsForColor = getEmphasizedCoveredPositionsForColor;
/* No side effect */


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_bs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _Board_bs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _Pieces_bs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);



// util function for converting 0,0 -> A1, etc.
function positionToId(x, y) {
    return `${String.fromCharCode(x + 65)}${y + 1}`;
}

const ScalingFactor = 4;
const AssetSize = 23;

class Colors {
    static white = 0;
    static black = 1;
}

class Tags {
    static pawn = 0;
    static king = 1;
    static queen = 2;
    static bishop = 3;
    static knight = 4;
    static rook = 5;
}

// adapt to rescript
class Adapters {
    static buildList(arr) {
        arr = arr.map(a => a).reverse();
        var lst = 0;
        for (var i = 0; i < arr.length; i++) {
            lst = {
                hd: arr[i],
                tl: lst
            }
        }
        return lst;
    }

    static buildArray(lst) {
        if (lst === 0 || lst === undefined) {
            return [];
        } else {
            return [lst.hd, ...Adapters.buildArray(lst.tl)];
        }
    }

    static board(pieces) {
        return {
            pieces: Adapters.buildList(pieces),
        }
    }

    static pawn(color, x, y) {
        return {
            TAG: /* Pawn */ 0,
            _0: {
                x: x,
                y: y,
                color: color,
                hasMoved: false,
                emphasizeCoverRange: false,
                hasJustMoved2Spaces: false
            }
        };
    }

    static king(color, x, y) {
        return {
            TAG: /* King */ 1,
            _0: {
                x: x,
                y: y,
                color: color,
                hasMoved: false,
                emphasizeCoverRange: false,
                inCheck: false,
                checkmated: false
            }
        };
    }

    static queen(color, x, y) {
        return {
            TAG: /* Queen */ 2,
            _0: {
                x: x,
                y: y,
                color: color,
                hasMoved: false,
                emphasizeCoverRange: false
            }
        };
    }

    static bishop(color, x, y) {
        return {
            TAG: /* Bishop */ 3,
            _0: {
                x: x,
                y: y,
                color: color,
                hasMoved: false,
                emphasizeCoverRange: false
            }
        };
    }

    static knight(color, x, y) {
        return {
            TAG: /* Knight */ 4,
            _0: {
                x: x,
                y: y,
                color: color,
                hasMoved: false,
                emphasizeCoverRange: false
            }
        }
    }

    static rook(color, x, y) {
        return {
            TAG: /* Rook */ 5,
            _0: {
                x: x,
                y: y,
                color: color,
                hasMoved: false,
                emphasizeCoverRange: false
            }
        };
    }
}

class Game {
    constructor() {
        this.board = Adapters.board([
            // white pawns
            Adapters.pawn(Colors.white, 0, 1),
            Adapters.pawn(Colors.white, 1, 1),
            Adapters.pawn(Colors.white, 2, 1),
            Adapters.pawn(Colors.white, 3, 1),
            Adapters.pawn(Colors.white, 4, 1),
            Adapters.pawn(Colors.white, 5, 1),
            Adapters.pawn(Colors.white, 6, 1),
            Adapters.pawn(Colors.white, 7, 1),
            // white pieces
            Adapters.rook(Colors.white, 0, 0),
            Adapters.rook(Colors.white, 7, 0),
            Adapters.knight(Colors.white, 1, 0),
            Adapters.knight(Colors.white, 6, 0),
            Adapters.bishop(Colors.white, 2, 0),
            Adapters.bishop(Colors.white, 5, 0),
            Adapters.queen(Colors.white, 3, 0),
            Adapters.king(Colors.white, 4, 0),
            // black pawns
            Adapters.pawn(Colors.black, 0, 6),
            Adapters.pawn(Colors.black, 1, 6),
            Adapters.pawn(Colors.black, 2, 6),
            Adapters.pawn(Colors.black, 3, 6),
            Adapters.pawn(Colors.black, 4, 6),
            Adapters.pawn(Colors.black, 5, 6),
            Adapters.pawn(Colors.black, 6, 6),
            Adapters.pawn(Colors.black, 7, 6),
            // black pieces
            Adapters.rook(Colors.black, 0, 7),
            Adapters.rook(Colors.black, 7, 7),
            Adapters.knight(Colors.black, 1, 7),
            Adapters.knight(Colors.black, 6, 7),
            Adapters.bishop(Colors.black, 2, 7),
            Adapters.bishop(Colors.black, 5, 7),
            Adapters.queen(Colors.black, 3, 7),
            Adapters.king(Colors.black, 4, 7),
        ]);
        this.turn = Colors.white;
        this.selectedPiece = null;
        this.legalMoves = null; // legal moves of currently selected piece
        // start cursor at white king
        this.cursorPosition = [4, 0];
        this.sounds = null;
        this.promote = false;
    }

    init() {
        var body = d3.select("body");
        body.on("keydown", () => {
            var key = d3.event.keyCode;
            switch (key) {
                case 38:
                case 87: // W
                    this.handleUp();
                    break;
                case 37:
                case 65: // A
                    this.handleLeft();
                    break;
                case 40:
                case 83: // S
                    this.handleDown();
                    break;
                case 39:
                case 68: // D
                    this.handleRight();
                    break;
                case 88: // X
                    this.handleSelect();
                    break;
                case 90: // Z
                    this.handleCancel();
                    break;
                case 66: // B
                case 78: // N
                case 82: // R
                case 81: // Q
                    this.handlePromote(key);
                    break;
            }
        });
        this.sounds = {
            "warning": new Howl({
                src: ['./assets/sounds/warning.flac'],
                autoplay: false,
                loop: false,
            }),
            "capture": new Howl({
                src: ['./assets/sounds/capture.flac'],
                autoplay: false,
                loop: false,
            }),
            "move": new Howl({
                src: ['./assets/sounds/move.wav'],
                autoplay: false,
                loop: false,
            }),
            "select": new Howl({
                src: ['./assets/sounds/select.wav'],
                autoplay: false,
                loop: false,
            }),
            "cursor": new Howl({
                src: ['./assets/sounds/cursor.wav'],
                autoplay: false,
                loop: false,
            }),
            "victory": new Howl({
                src: ['./assets/sounds/victory1.flac'],
                autoplay: false,
                loop: false,
            }),
            "white_turn": new Howl({
                src: ['./assets/sounds/white_turn.flac'],
                autoplay: false,
                loop: false,
            }),
            "black_turn": new Howl({
                src: ['./assets/sounds/black_turn.flac'],
                autoplay: false,
                loop: false,
            }),
        }
        this.handleTurnStart();
        this.draw();
    }

    handleTurnStart() {
        this.selectedPiece = null;
        this.legalMoves = null;
        var color = this.turn;
        // make sure player is not checkmated
        var otherColor = _Utils_bs_js__WEBPACK_IMPORTED_MODULE_0__.oppositeColor(color);
        var ownKing = Adapters.buildArray(this.board.pieces).filter(
            p => p._0.color === color && p.TAG === 1 // king
        )[0];
        var otherCoveredPositions = Adapters.buildArray(_Pieces_bs_js__WEBPACK_IMPORTED_MODULE_2__.getCoveredPositionsForColor(this.board, otherColor));
        var ownKingInCheck = otherCoveredPositions
            .find(p => p[0] === ownKing._0.x && p[1] === ownKing._0.y) !== undefined;
        var legalMoves = Adapters.buildArray(this.board.pieces).filter(
            p => p._0.color === color
        ).reduce((acc, p) => acc + Adapters.buildArray(_Pieces_bs_js__WEBPACK_IMPORTED_MODULE_2__.getLegalMoves(p, this.board)).length, 0);
        if (legalMoves === 0) {
            // lock the game for now
            this.winSound();
            this.lock = true;
            if (ownKingInCheck) {
                alert(`${this.color === Colors.black ? "White" : "Black"} has won! Refresh the page to play again.`);
            } else {
                alert("Stalemate! Refresh the page to play again.");
            }
            return;
        }
        this.turnStartSound();
        this.draw();
    }

    winSound() {
        this.sounds.victory.play();
    }

    cursorSound() {
        this.sounds.cursor.play();
    }

    successSound() {
        this.sounds.select.play();
    }

    failureSound() {
        this.sounds.warning.play();
    }

    moveSound() {
        this.sounds.move.play()
    }

    turnStartSound() {
        if (this.turn === Colors.white) {
            this.sounds.white_turn.play();
        } else {
            this.sounds.black_turn.play();
        }
    }

    captureSound() {
        this.sounds.capture.play();
    }

    handleSelect() {
        if (this.lock) return;
        if (this.selectedPiece === undefined || this.selectedPiece === null) {
            // no piece selected
            var piece = _Board_bs_js__WEBPACK_IMPORTED_MODULE_1__.getPiece(
                this.board,
                this.cursorPosition,
                undefined
            );
            if (piece === undefined) {
                // select nothing
                this.failureSound();
            } else if (piece._0.color === this.turn) {
                // select friendly piece
                this.selectedPiece = piece;
                this.legalMoves = Adapters.buildArray(_Pieces_bs_js__WEBPACK_IMPORTED_MODULE_2__.getLegalMoves(piece, this.board));
                this.successSound();
                this.draw();
            } else {
                // select enemy piece - toggle cover range highlight
                piece.emphasizeCoverRange = !piece.emphasizeCoverRange;
                this.successSound();
                this.draw();
            }
        } else {
            // friendly piece already selected
            var target_piece = _Board_bs_js__WEBPACK_IMPORTED_MODULE_1__.getPiece(
                this.board,
                this.cursorPosition,
                undefined
            );
            if (target_piece === undefined || target_piece._0.color !== this.turn) {
                // select empty space or enemy piece - try to move
                var legalMove = this.legalMoves.filter(m =>
                    m[0] === this.cursorPosition[0] &&
                    m[1] === this.cursorPosition[1]
                );
                if (legalMove.length > 0) {
                    var move = legalMove[0];
                    var pieces = Adapters.buildArray(this.board.pieces).length;
                    this.lock = true;
                    this.board = _Board_bs_js__WEBPACK_IMPORTED_MODULE_1__.confirmMove(this.board, this.selectedPiece, move);
                    // end confirm move logic
                    if (pieces > Adapters.buildArray(this.board.pieces).length) {
                        this.captureSound();
                    } else {
                        this.moveSound();
                    }
                    this.draw();
                    if (this.selectedPiece.TAG === Tags.pawn && _Utils_bs_js__WEBPACK_IMPORTED_MODULE_0__.isPromotionEligible(this.selectedPiece._0)) {
                        this.promote = true;
                    } else {
                        this.endTurn();
                    }
                } else {
                    this.failureSound();
                }
            } else {
                // select different friendly piece
                if (
                    this.cursorPosition[0] !== this.selectedPiece._0.x ||
                    this.cursorPosition[1] !== this.selectedPiece._0.y
                ) {
                    this.selectedPiece = target_piece;
                    this.legalMoves = Adapters.buildArray(_Pieces_bs_js__WEBPACK_IMPORTED_MODULE_2__.getLegalMoves(target_piece, this.board));
                    this.successSound();
                    this.draw();
                }
            }
        }
    }

    endTurn() {
        setTimeout(() => {
            this.lock = false;
            this.turn = _Utils_bs_js__WEBPACK_IMPORTED_MODULE_0__.oppositeColor(this.turn);
            this.handleTurnStart();
        }, 1000);
    }

    handleCancel() {
        if (this.lock) return;
        if (this.selectedPiece !== null) {
            this.successSound();
            this.selectedPiece = null;
            this.legalMoves = null;
            this.draw();
        } else {
            this.failureSound();
        }
    }

    handleLeft() {
        if (this.lock) return;
        if (this.turn === Colors.white) {
            if (this.cursorPosition[0] > 0) {
                this.cursorPosition[0] -= 1;
                this.handleMoveCursor();
            }
        } else {
            if (this.cursorPosition[0] < 7) {
                this.cursorPosition[0] += 1;
                this.handleMoveCursor();
            }
        }
    }

    handleRight() {
        if (this.lock) return;
        if (this.turn === Colors.white) {
            if (this.cursorPosition[0] < 7) {
                this.cursorPosition[0] += 1;
                this.handleMoveCursor();
            }
        } else {
            if (this.cursorPosition[0] > 0) {
                this.cursorPosition[0] -= 1;
                this.handleMoveCursor();
            }
        }
    }

    handleDown() {
        if (this.lock) return;
        if (this.turn === Colors.white) {
            if (this.cursorPosition[1] > 0) {
                this.cursorPosition[1] -= 1;
                this.handleMoveCursor();
            }
        } else {
            if (this.cursorPosition[1] < 7) {
                this.cursorPosition[1] += 1;
                this.handleMoveCursor();
            }
        }
    }

    handleUp() {
        if (this.lock) return;
        if (this.turn === Colors.white) {
            if (this.cursorPosition[1] < 7) {
                this.cursorPosition[1] += 1;
                this.handleMoveCursor();
            }
        } else {
            if (this.cursorPosition[1] > 0) {
                this.cursorPosition[1] -= 1;
                this.handleMoveCursor();
            }
        }
    }

    handleMoveCursor() {
        this.cursorSound();
        this.draw();
    }

    handlePromote(key) {
        if (!this.promote) return;
        var piece;
        switch (key) {
            case 66: // B
                piece = Adapters.bishop(this.selectedPiece.color, this.selectedPiece._0.x, this.selectedPiece._0.y);
                break;
            case 78: // N
                piece = Adapters.knight(this.selectedPiece.color, this.selectedPiece._0.x, this.selectedPiece._0.y);
                break;
            case 82: // R
                piece = Adapters.rook(this.selectedPiece.color, this.selectedPiece._0.x, this.selectedPiece._0.y);
                break;
            case 81: // Q
                piece = Adapters.queen(this.selectedPiece.color, this.selectedPiece._0.x, this.selectedPiece._0.y);
                break;
        }
        var pieces = Adapters.buildArray(this.board.pieces).filter(p => p._0.x != piece._0.x || p._0.y != piece._0.y);
        pieces.push(piece);
        this.board.pieces = Adapters.buildList(pieces);
        this.promote = false;
        this.winSound(); // TODO - get unique promote sound
        this.draw();
        this.endTurn();
    }

    draw() {
        var otherColor = _Utils_bs_js__WEBPACK_IMPORTED_MODULE_0__.oppositeColor(this.turn);
        var coveredPositions = Adapters.buildArray(_Pieces_bs_js__WEBPACK_IMPORTED_MODULE_2__.getCoveredPositionsForColor(this.board, otherColor));
        var emphasizedCoveredPositions = Adapters.buildArray(_Pieces_bs_js__WEBPACK_IMPORTED_MODULE_2__.getEmphasizedCoveredPositionsForColor(this.board, otherColor));

        var grid = [];
        for (var i = 0; i < 8; i++) {
            var row = [];
            for (var j = 0; j < 8; j++) {
                row.push(new Grid(i, j, this.turn));
            }
            grid.push(row);
        }

        Adapters.buildArray(this.board.pieces).forEach(p => {
            grid[p._0.x][p._0.y].piece = p;
        });

        coveredPositions.forEach(p => {
            grid[p[0]][p[1]].covered = true;
        });
        emphasizedCoveredPositions.forEach(p => {
            grid[p[0]][p[1]].covered2 = true;
        });

        grid[this.cursorPosition[0]][this.cursorPosition[1]].selection = true;
        if (this.selectedPiece !== null && this.selectedPiece !== undefined) {
            grid[this.selectedPiece._0.x][this.selectedPiece._0.y].selection = true;
                if (this.legalMoves !== null) {
                this.legalMoves.forEach(p => {
                    grid[p[0]][p[1]].movement = true;
                });
            }
        }
        var svg = d3.select("#board");
        svg.selectAll('*').remove();
        grid.forEach(row => {
            row.forEach(x => x.draw(svg));
        });
    }
}

class Grid {
    // class for rendering a grid in the chess board
    constructor(x, y, turnColor) {
        this.piece = null;
        this.selection = false;
        this.covered = false;
        this.covered2 = false;
        this.movement = false;
        this.x = x;
        this.y = y;
        this.turnColor = turnColor;
    }

    draw(svg) {
        var gridSize = ScalingFactor * AssetSize;
        // starting position for cursor - top left of box
        var posX;
        var posY;
        if (this.turnColor === Colors.white) {
            // A1 is bottom left
            posX = this.x * gridSize;
            posY = (7 - this.y) * gridSize;
        } else {
            // A1 is top right
            posX = (7 - this.x) * gridSize;
            posY = this.y * gridSize;
        }
        var g = svg.append("g")
            .attr("class", positionToId(this.x, this.y));

        // draw base square
        var inCheck = this.piece !== undefined && this.piece !== null && this.piece.TAG === Tags.king &&
            this.piece._0.color === this.turnColor && this.covered;
        var color = (this.x % 2 === this.y % 2) ? "maroon" : "antiquewhite";
        g.append("rect")
            .attr("width", gridSize)
            .attr("height", gridSize)
            .attr("transform", `translate(${posX} ${posY})`)
            .attr("fill", inCheck ? "red" : color);

        // draw overlay (movement and cover)
        var overlayColor = null;
        if (this.covered2 && !this.movement && !inCheck) {
            overlayColor = "red";
        } else if (
            this.covered && this.piece !== null &&
            !inCheck && !this.movement
        ) {
            overlayColor = "lightcoral";
        } else if (this.movement && this.covered) {
            overlayColor = "purple";
        } else if (this.movement) {
            overlayColor = "blue";
        }
        if (overlayColor !== null) {
            g.append("rect")
                .attr("width", gridSize)
                .attr("height", gridSize)
                .attr("transform", `translate(${posX} ${posY})`)
                .attr("fill", overlayColor)
                .style("opacity", 0.8);
        }

        // sprite
        if (this.piece !== undefined && this.piece !== null) {
            g.append("image")
                .attr("transform", `translate(${posX} ${posY})`)
                .attr("width", gridSize)
                .attr("height", gridSize)
                .attr("id", positionToId(this.x, this.y))
                .attr("xlink:href", `./${_Utils_bs_js__WEBPACK_IMPORTED_MODULE_0__.getAsset(this.piece)}.gif`);
        }

        // selection box
        if (this.selection) {
            var stroke = ScalingFactor * 3;
            g.append("rect")
                .attr("width", gridSize - stroke)
                .attr("height", gridSize - stroke)
                .attr("transform", `translate(${posX + stroke/2} ${posY + stroke/2})`)
                .attr("fill", "none")
                .attr("stroke-width", `${stroke}px`)
                .attr("class", "selection")
                .attr("stroke", "goldenrod");
        }
    }
}

window.onload = () => {
    var game = new Game();
    game.init();
}
})();

/******/ })()
;