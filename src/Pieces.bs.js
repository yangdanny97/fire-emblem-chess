// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Board from "./Board.bs.js";
import * as Utils from "./Utils.bs.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";

function getLegalMoves(piece, board) {
  return /* [] */0;
}

var King = {
  getLegalMoves: getLegalMoves
};

function getLegalMoves$1(piece, board) {
  return /* [] */0;
}

function isPromotionEligible(piece, board) {
  if (piece.color === /* White */0 && piece.y === 7) {
    return true;
  } else if (piece.color === /* Black */1) {
    return piece.y === 0;
  } else {
    return false;
  }
}

var Pawn = {
  getLegalMoves: getLegalMoves$1,
  isPromotionEligible: isPromotionEligible
};

function getAsset(piece) {
  switch (piece.TAG | 0) {
    case /* Pawn */0 :
        return "assets/" + Utils.colorName(piece._0.color) + "/pawn";
    case /* King */1 :
        return "assets/" + Utils.colorName(piece._0.color) + "/king";
    case /* Queen */2 :
        return "assets/" + Utils.colorName(piece._0.color) + "/queen";
    case /* Bishop */3 :
        return "assets/" + Utils.colorName(piece._0.color) + "/bishop";
    case /* Knight */4 :
        return "assets/" + Utils.colorName(piece._0.color) + "/knight";
    case /* Rook */5 :
        return "assets/" + Utils.colorName(piece._0.color) + "/rook";
    
  }
}

function getColor(piece) {
  return piece._0.color;
}

function canCover(piece, board, position) {
  var p = Board.getPiece(board, position, undefined);
  if (p !== undefined && (p.TAG === /* King */1 || p._0.color === piece.color)) {
    return true;
  } else {
    return Board.checkUnobstructed(board, piece, position, false);
  }
}

function getUnobstructedCardinalPositions(piece, board) {
  var up = Belt_List.sort(Belt_List.keep(board.pieces, (function (p) {
              if (p.x === piece.x) {
                return p.y > piece.y;
              } else {
                return false;
              }
            })), (function (a, b) {
          return a.y - b.y | 0;
        }));
  var down = Belt_List.sort(Belt_List.keep(board.pieces, (function (p) {
              if (p.x === piece.x) {
                return p.y < piece.y;
              } else {
                return false;
              }
            })), (function (a, b) {
          return b.y - a.y | 0;
        }));
  var left = Belt_List.sort(Belt_List.keep(board.pieces, (function (p) {
              if (p.y === piece.y) {
                return p.x < piece.x;
              } else {
                return false;
              }
            })), (function (a, b) {
          return b.x - a.x | 0;
        }));
  var right = Belt_List.sort(Belt_List.keep(board.pieces, (function (p) {
              if (p.y === piece.y) {
                return p.x > piece.x;
              } else {
                return false;
              }
            })), (function (a, b) {
          return a.x - b.x | 0;
        }));
  var positionHelper = function (acc, position) {
    if (!acc[0]) {
      return [
              false,
              acc[1]
            ];
    }
    var lst = acc[1];
    if (canCover(piece, board, position)) {
      if (Board.hasPiece(board, position, undefined)) {
        return [
                false,
                {
                  hd: position,
                  tl: lst
                }
              ];
      } else {
        return [
                true,
                {
                  hd: position,
                  tl: lst
                }
              ];
      }
    } else {
      return [
              false,
              lst
            ];
    }
  };
  return Belt_List.flatten(Belt_List.map({
                  hd: up,
                  tl: {
                    hd: down,
                    tl: {
                      hd: left,
                      tl: {
                        hd: right,
                        tl: /* [] */0
                      }
                    }
                  }
                }, (function (l) {
                    return Belt_List.reduce(l, [
                                  true,
                                  /* [] */0
                                ], positionHelper)[1];
                  })));
}

function getUnobstructedDiagonalPositions(piece, board) {
  return /* [] */0;
}

function getCoveredPositions(piece, board) {
  return /* [] */0;
}

function getLegalMoves$2(piece, board) {
  switch (piece.TAG | 0) {
    case /* Pawn */0 :
    case /* King */1 :
        return /* [] */0;
    default:
      return Belt_List.keep(/* [] */0, (function (pos) {
                    return Board.validStateForMove(board, piece, pos);
                  }));
  }
}

export {
  King ,
  Pawn ,
  getAsset ,
  getColor ,
  canCover ,
  getUnobstructedCardinalPositions ,
  getUnobstructedDiagonalPositions ,
  getCoveredPositions ,
  getLegalMoves$2 as getLegalMoves,
  
}
/* No side effect */
